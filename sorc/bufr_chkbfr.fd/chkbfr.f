C$$$  MAIN PROGRAM DOCUMENTATION BLOCK
C
C MAIN PROGRAM: BUFR_CHKBFR
C   PRGMMR: MELCHIOR         ORG: NP22        DATE: 2018-10-29
C
C ABSTRACT: CHECKS A LIST OF BUFR FILES (ALL IN THE SAME GROUP,
C   USUALLY ALL OF THE SAME MESSAGE TYPE AND ALWAYS ALL USING THE
C   SAME DICTIONARY MESSAGES), DETERMINING WHETHER THEY CONTAIN
C   ANY DATA OR NOT. SEVERAL LEVELS OF RETURN CODE ARE AVAILABLE FROM
C   THE PROGRAM INDICATING WHETHER ANY OR ALL THE FILES HAVE DATA.
C   ALSO, A STATUS LINE IS PRINTED FOR EACH FILE ALONG WITH A
C   REPORT COUNT (AND FOR SOME SATELLITE TYPES, COUNTS BY SATELLITE
C   ID ARE PRINTED).  THE REPORT COUNT REPRESENTS A BUFR SUBSET COUNT
C   FOR ALL TYPES EXCEPT NEXRAD RADAR LEVEL 3 AND 2.5 RADIAL WIND DATA
C   IN BUFR TYPES NC006001 AND NC006002, RESP. - HERE THE REPORT
C   COUNT IS THE TOTAL NUMBER OF RADIAL WIND "OBSERVATIONS" OBTAINED
C   FROM THE NUMBER OF REPLICATIONS OF RADIAL WIND (ALTHOUGH THE SUBSET
C   COUNT IS ALSO PRINTED AS SECONDARY INFORMATION).  EACH RADIAL WIND
C   SUBSET (A STATION AT A PARTICULAR SCAN ANGLE AT A PARTICULAR TIME)
C   CAN CONTAIN UP TO SEVERAL HUNDRED "OBSERVATIONS".  THE COUNTS OF
C   NEXRAD RADAR LEVEL 2 RADIAL WIND AND REFLECTIVITY OBS IN BUFR
C   TYPES NC006010 TO NC006033 AND NC006040 TO NC006063, RESP., AS WELL
C   AS TDR RADIAL WIND IN BUFR TYPE NC006070 ARE CURRENTLY DERIVED FROM
C   A SUBSET COUNT (LIKE THE NON-RADAR TYPES), BECAUSE THE TOTAL NUMBER
C   OF REPLICATIONS IS OFTEN TOO LARGE TO FIT IN THE SUBSEQUENT DUMP
C   STATUS FILE PRINT FORMAT (THERE ARE SO MUCH DATA).  THE NUMBER OF
C   LEVEL 2 RADIAL WIND AND REFLECTIVITY REPLICATIONS AND TDR RADIAL
C   WIND REPLICATIONS FOR EACH SUBTYPE IS, HOWEVER, PRINTED HERE AS
C   SECONDARY INFORMATION (MUCH LIKE THE COUNTS BY SATELLITE ID ARE FOR
C   THE VARIOUS SATELLITE SUBTYPES).
C
C PROGRAM HISTORY LOG:
C 1996-11-22  J. WOOLLEN  ORIGINAL VERSION FOR IMPLEMENTATION
C 1999-06-03  D. KEYSER   MODIFIED TO PORT TO IBM SP AND RUN IN 4 OR
C     8 BYTE STORAGE
C 2004-03-02  D. KEYSER   ADDED FLEXIBILITY IN READING AND CHECKING
C     INPUT FILE NAMES; ADDED PRINTS OF COUNTS BY SATELLITE ID FOR
C     APPLICABLE TYPES (PRINTED UNDER TOTAL DUMP COUNT FOR FILE);
C     REPLACED CALL TO IN-LINE SUBROUTINE COMPRESS_CHECK WITH CALL TO
C     NEW BUFRLIB ROUTINE MESGBC; REPORT COUNTS FOR LEVEL 3/2.5 RADIAL
C     WIND RADAR DATA IN BUFR TYPE NC006001/NC006002 ARE NOW THE TOTAL
C     NUMBER OF "LEVELS" AMONGST ALL SUBSETS IN THE BUFR MESSAGES
C     RATHER THAN JUST THE NUMBER OF SUBSETS AS BEFORE SINCE EACH
C     SUBSET REPRESENTS ONLY A RADAR STATION AND TILT ANGLE FOR A
C     SPECIFIC HOUR AND EACH SUBSET CAN HAVE UP TO SEVERAL HUNDRED
C     LEVELS (RADIAL WIND "OBSERVATIONS")
C 2005-10-19  D. KEYSER   INTRODUCED ALLOCATABLE ARRAYS TO AVOID ARRAY
C     OVERFLOW PROBLEMS, DETERMINES SIZE OF ARRAYS BY CALLING UFBTAB
C     WITH NEGATIVE UNIT NUMBER TO SIMPLY COUNT SUBSETS; FOR SATELLITE
C     TYPES STORED IN COMPRESSED BUFR MESSAGES  (I.E., AIRS, ATOVS 1B,
C     AVHRR) ENABLED CAPACITY TO MORE EFFICIENTLY COUNT SUBSETS BY
C     SATELLITE ID VIA DIRECT CALL TO BUFRLIB ROUTINE UFBTAB RATHER
C     THAN HAVING TO FIRST UNCOMPRESS THE ENTIRE FILE BEFORE CALLING
C     UFBTAB, DONE THROUGH TEMPORARY IN-LINE VERSION OF UFBTAB WHICH
C     CAN NOW HANDLE COMPRESSED MESSAGES (THIS WILL BE IMPLEMENTED IN
C     NEXT VERSION OF BUFRLIB AFTERWHICH UFBTAB SHOULD BE REMOVED
C     HERE)
C 2006-03-02  D. KEYSER   IMPROVED DOCUMENTATION, COMMENTS, STREAMLINED
C     CODE; CHANGES TO HANDLE NEXRAD LEVEL 2 RADIAL WIND REPORTS IN
C     MESSAGE TYPE NC006010 TO NC006033 AND NEXRAD LEVEL 2 REFLECTIVITY
C     REPORTS IN NC006040 TO NC006063; ADDED STATUS FILE IN UNIT 60
C     THAT IS WRITTEN TO ONLY WHEN THIS PROGRAM COMPLETES SUCCESSFULLY
C     (TRANSF. TO DUMPJB SCRIPT);  REMOVES IN-LINE VERSION OF UFBTAB
C     (UPDATED TO HANDLE COMPRESSED BUFR MESSAGES IN 1/31/2006 VERSION
C     OF BUFRLIB)
C 2006-05-22  D. KEYSER   MODIFIED TO ONLY OPEN FILES THAT ARE NOT
C     EMPTY FOR BOTH COPYING THE INTERNAL DICTIONARY MESSAGES TO THE
C     "CHECK" FILE (FIRST NON-EMPTY FILE ONLY) AND COUNTING REPORTS,
C     THIS ELIMINATES WARNING MESSAGES THAT HAD BEEN GENERATED BY
C     BUFRLIB ROUTINE OPENBF WHEN IT TRIED TO OPEN A FILE THAT DID NOT
C     EXIST
C 2007-03-23  D. KEYSER   CORRECTED METHOD OF CALLING UFBTAB WITH
C     NEGATIVE UNIT NUMBER TO COUNT SUBSETS FOR USE WITH EXISTING
C     ALLOCATABLE ARRAYS (RADAR AND SATELLITE DATA ONLY), PREVIOUS
C     LOGIC COULD HAVE LEAD TO ARRAY OVERFLOW PROBLEMS - STREAMLINED
C     THIS LOGIC AS WELL
C 2007-08-07  D. KEYSER   ADDED V6 BUFR SBUV (NC008010) AND V8 BUFR
C     SBUV (NC008011) TO LIST OF SATELLITE TYPES FOR WHICH PRINTS OF
C     COUNTS BY SATELLITE ID ARE ADDED UNDER TOTAL DUMP COUNT IN
C     STANDARD OUTPUT PRINT
C 2008-05-05  D. KEYSER   ADDED GOME (NC008012) TO LIST OF SATELLITE
C     TYPES FOR WHICH PRINTS OF COUNTS BY SATELLITE ID ARE ADDED UNDER
C     TOTAL DUMP COUNT IN STANDARD OUTPUT PRINT
C 2010-02-26  D. KEYSER   ADDED OMI (NC008013) TO LIST OF SATELLITE
C     TYPES FOR WHICH PRINTS OF COUNTS BY SATELLITE ID ARE ADDED UNDER
C     TOTAL DUMP COUNT IN STANDARD OUTPUT PRINT; ADDED TDL RADAR RADIAL
C     WINDS (NC006070) TO LIST OF RADAR TYPES (ALONG WITH L2) FOR WHICH
C     THE TOTAL NUMBER OF REPLICATIONS IS PRINTED AS SECONDARY
C     INFORMATION
C 2012-11-20  J. WOOLLEN  INITIAL PORT TO WCOSS - ADDED SETBMISS CALL
C 2013-01-13  J. WHITING  FINAL WCOSS PORT -- UPDATED DOC BLOCKS, NO
C     LOGIC CHANGES.
C 2018-10-29  S. MELCHIOR ADDED V8 BUFR OMPS NP (NC008017) AND V8
C     BUFR OMPS TC (NC008018) TO LIST OF SATELLITE TYPES FOR WHICH
C     PRINTS OF COUNTS BY SATELLITE ID ARE ADDED UNDER TOTAL DUMP
C     COUNT IN STANDARD OUTPUT PRINT
C 
C
C USAGE:
C   INPUT FILES:
C     UNIT 05  - STANDARD INPUT - EACH RECORD CONTAINS A FILENAME
C                ASSOCIATED WITH A PARTICULAR INPUT BUFR FILE (IN A
C                FORM nn_ttt.sss, where "nn" is a number, "ttt" is
C                the BUFR message type for the file, and "sss" is the
C                BUFR message subtype for the file)
C     UNIT 20  - UNIT NUMBER CONNECTED TO EACH INPUT FILENAME READ
C                FROM STANDARD INPUT (ONE AT A TIME)
C     UNIT 21  - NULL FILE HOLDING DICTIONARY MESSAGES ACTUALLY USED
C                FOR CHECKING COUNTS (FOR ALL INPUT FILES)-"CHECK" FILE
C     UNIT 30  - CHARACTER GROUP NAME (e.g., "satwnd")
c
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C     UNIT 60  - STATUS FILE WHOSE PRESENCE INDICATES THIS PROGRAM
C                COMPLETED SUCCESSFULLY
C
C   SUBPROGRAMS CALLED:
C     UNIQUE:   - NONE
C     LIBRARY:
C      W3NCO    - W3TAGB W3TAGE
C      BUFRLIB  - MESGBC OPENBF CLOSBF UFBTAB SETBMISS
C
C   EXIT STATES:
C     COND =   0 - ALL  OF THE INPUT FILES CONTAINED DATA
C     COND =  11 - SOME OF THE INPUT FILES CONTAINED DATA
C     COND =  22 - NONE OF THE INPUT FILES CONTAINED DATA
C
C REMARKS:
C     THIS CODE IS TAILORED FOR THE DUMPJB SCRIPT.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      PROGRAM BUFR_CHKBFR
 
      REAL(8),ALLOCATABLE :: SAID_8(:)
      REAL(8),ALLOCATABLE :: TAB_8(:)
      REAL,ALLOCATABLE :: SAID(:)
      REAL,ALLOCATABLE :: TAB(:)

      CHARACTER*80 FILENAME,NULL
      CHARACTER*8  SUBSET,GROUP
      REAL(8)      UFBTAB_8
      LOGICAL      SOME,NONE,CHECK_FILE,SAT,RADAR,RADAR_L2
      DIMENSION    KOUNT(1:1023)
 
      DATA NULL/ '/dev/null' /,iprint/0/
 
      DATA LUNIN /20/
      DATA LUNDX /21/
 
C-----------------------------------------------------------------------
C-----------------------------------------------------------------------

      CALL W3TAGB('BUFR_CHKBFR',2018,0302,0050,'NP22')

      PRINT'(" ==> Welcome to BUFR_CHKBFR -- Version 10-29-2018"/)'


C  Set BUFR "missing" values from their default of 10.e10 to the smaller
C   10.e8 -- this is necessary to avoid integer overflow problems ( ie,
C   NINT(SAID(I)) ) and subsequent KOUNT array bounds errors when
C   checking for IDs greater than 1023 (later in code).

      CALL SETBMISS(10E08_8)



      ISATF  = 0
      IRAD2F = 0
      IRADF  = 0

      SOME = .FALSE.
      NONE = .FALSE.
      CHECK_FILE = .FALSE.

      READ(30,'(A8)',END=5) GROUP
      GOTO 6
    5 CONTINUE
      GROUP = '????????'
    6 CONTINUE
 
C  OPEN A NULL FILE WHICH WILL HOLD DICTIONARY MESSAGES ACTUALLY USED
C   FOR CHECKING COUNTS (FOR ALL NON-EMPTY INPUT FILES)
C   - CALL THIS THE "CHECK" FILE
C  ------------------------------------------------------------------
 
      OPEN(LUNDX,FILE=NULL,FORM='UNFORMATTED')

C  LOOP THROUGH THE INPUT BUFR FILES IN THE LIST
C  ---------------------------------------------

      DO INFILE = 1,10000

         READ(5,'(Q,A)',END=3) NBYTES_FILE,FILENAME(1:NBYTES_FILE)
         OPEN(LUNIN,FILE=FILENAME(1:NBYTES_FILE),FORM='UNFORMATTED')

         CALL MESGBC(LUNIN,MSGT,ICOMP)
         IF(IPRINT.EQ.1) THEN
            IF(ICOMP.EQ.1) THEN
               PRINT'(/"INPUT BUFR FILE",A," MESSAGES   '//
     .        'C O M P R E S S E D"/"FIRST MESSAGE TYPE FOUND IS",I5/)',
     .         FILENAME(1:NBYTES_FILE), MSGT
            ELSE  IF(ICOMP.EQ.0) THEN
               PRINT'(/"INPUT BUFR FILE",A," MESSAGES   '//
     .       'U N C O M P R E S S E D"/"FIRST MESSAGE TYPE FOUND IS",'//
     .          'I5/)', FILENAME(1:NBYTES_FILE), MSGT
            ELSE  IF(ICOMP.EQ.-3)  THEN
               PRINT'(/"INPUT BUFR FILE",A," DOES NOT EXIST"/)',
     .          FILENAME(1:NBYTES_FILE)
            ELSE  IF(ICOMP.EQ.-2)  THEN
               PRINT'(/"INPUT BUFR FILE",A," HAS NO DATA MESSAGES"/'//
     .          '"FIRST MESSAGE TYPE FOUND IS",I5/)',
     .          FILENAME(1:NBYTES_FILE),MSGT
            ENDIF
         ENDIF
         IF(ICOMP.EQ.-1)  THEN
            PRINT'(//"ERROR READING INPUT BUFR FILE",A," - MESSAGE '//
     .       'COMPRESSION UNKNOWN"/)', FILENAME(1:NBYTES_FILE)
         ENDIF

C  FIND FIRST FILE WHICH CONTAINS INTERNAL DICTIONARY MESSAGES (MAY NOT
C   NECESSARILY BE FIRST FILE READ SINCE IT COULD BE EMPTY)
C  --------------------------------------------------------------------

         IF(.NOT.CHECK_FILE) THEN
 
C      "CHECK" FILE NOT YET GENERATED SO OPEN BUFR FILE USING ITS OWN
C        INTERNAL DICTIONARY MESSAGES AND CHECK TO SEE IF FILE ACTUALLY
C        CONTAINS SUCH MESSAGES
C      ----------------------------------------------------------------

            print *
            print *, '--> Open file ',FILENAME(1:NBYTES_FILE)
            IF(MSGT.GT.-256) THEN

C         INTERNAL DICTIONARY MESSAGES FOUND, COPY THEM TO "CHECK" FILE
C         -------------------------------------------------------------

               CALL OPENBF(LUNIN,'IN',LUNIN)
               CALL OPENBF(LUNDX,'IN',LUNIN)
               CHECK_FILE = .TRUE.
               print'("        File ",A," is first to contain '//
     .          'internal dictionary msgs - copy them to ""check"" '//
     .          'file"/)', FILENAME(1:NBYTES_FILE)
            ELSE
               print'("        File ",A," does not contain internal '//
     .          'dictionary msgs - must be empty"/)',
     .          FILENAME(1:NBYTES_FILE)
            ENDIF
         ELSE

C      "CHECK" FILE ALREADY GENERATED SO OPEN BUFR FILE USING
C       DICTIONARY MESSAGES FROM "CHECK" FILE
C      ------------------------------------------------------

            CALL OPENBF(LUNIN,'IN',LUNDX)
            print'(/"--> Open file ",A," using dictionary msgs from '//
     .       '""check"" file"/)', FILENAME(1:NBYTES_FILE)
         ENDIF

         DO  I=4,10
            IF(FILENAME(I:I).EQ.'.')  THEN
               JJJ = I
               EXIT
            ENDIF
         ENDDO

         NREP      = 0
         IFLAG     = 0
         KOUNT     = 0
         ICOUNT2   = 0
         ICOUNT    = 0

         SAT=
     .(FILENAME(JJJ-3:JJJ-1).EQ.'003'.OR.FILENAME(JJJ-3:JJJ-1).EQ.'005'
     . .OR.
     . FILENAME(JJJ-3:JJJ-1).EQ.'012'.OR.FILENAME(JJJ-3:JJJ-1).EQ.'021'
     . .OR.
     . FILENAME(JJJ-3:JJJ+3).EQ.'008.010'
     . .OR.
     . FILENAME(JJJ-3:JJJ+3).EQ.'008.011'
     . .OR.
     . FILENAME(JJJ-3:JJJ+3).EQ.'008.012'
     . .OR.
     . FILENAME(JJJ-3:JJJ+3).EQ.'008.013'
     . .OR.
     . FILENAME(JJJ-3:JJJ+3).EQ.'008.017'
     . .OR.
     . FILENAME(JJJ-3:JJJ+3).EQ.'008.018')

C  DISTINGUISH BETWEEN SATELLITE, LEVEL 2 RADAR, TDR RADAR AND LEVEL 3/
C   2.5 RADAR TYPES.  FOR ALL TYPES EXCEPT LEVEL 3/2.5 RADAR, PRIMARY
C   PRINT IS TOTAL NUMBER OF SUBSETS IN EACH SUBTYPE.  FOR SATELLITE
C   AND LEVEL 2 AND TDR RADAR TYPES, A SECONDARY PRINT IS ALSO
C   GENERATED: SATELLITE TYPES GET COUNTS BROKEN DOWN ACCORDING TO
C   SATELLITE ID, LEVEL 2 AND TDR RADAR TYPES GET TOTAL COUNT OF
C   REPLICATED "OBS" IN EACH SUBTYPE.  FOR LEVEL 3/2.5 RADAR, PRIMARY
C   PRINT IS TOTAL COUNT OF REPLICATED "OBS" IN EACH SUBTYPE AND
C   SECONDARY PRINT IS TOTAL NUMBER OF SUBSETS IN EACH SUBTYPE.
C  --------------------------------------------------------------------

ccccc    RADAR=(FILENAME(JJJ-3:JJJ-1).EQ.'006')
         RADAR=(FILENAME(JJJ-3:JJJ-1).EQ.'006'.AND.
     .          FILENAME(JJJ+1:JJJ+3).LE.'002')
         RADAR_L2=(.NOT.RADAR .AND. FILENAME(JJJ-3:JJJ-1).EQ.'006')

cccccccc CALL OPENBF(0,'QUIET',1) ! will generate diagnostic print if
cccccccc                          ! an embedded BUFR table is read
         IF(MSGT.GT.-256) THEN
            DO WHILE(IREADMG(LUNIN,SUBSET,IDATE).EQ.0)
               NREP = NREP+NMSUB(LUNIN)  ! accumulate rpt counts by msg
            ENDDO
         ENDIF
cccccccc CALL OPENBF(0,'QUIET',0) ! return to default wrt degree of prnt

C  READY TO PRINT COUNTS FOR ALL TYPES EXCEPT LEVEL 3/2.5 RADAR
C  ------------------------------------------------------------

         IF(.NOT.RADAR)
     .    PRINT'(A7,"  HAS ",I8," REPORTS")',FILENAME(JJJ-3:JJJ+3),NREP
         IF(NREP.GT.0) SOME = .TRUE.
         IF(NREP.EQ.0) NONE = .TRUE.
         CALL CLOSBF(LUNIN)
         IF(SAT.OR.RADAR_L2.OR.RADAR)  THEN

C  FOR SATELLITE TYPES OBTAIN, (AND ACCUMLATE) COUNTS BY SAT ID
C  FOR LEVEL 2 AND TDR RADAR TYPES, OBTAIN (AND ACCUMULATE) COUNTS OF
C   REPLICATED SEQUENCES OF RADIAL WIND AND REFLECTIVITY "OBSERVATIONS"
C  FOR LEVEL 2.5/3 RADAR TYPES, OBTAIN (AND ACCUMULATE) COUNTS OF
C   REPLICATED SEQUENCES OF RADIAL WIND "OBSERVATIONS"
C  ALL VIA UFBTAB
C  ------------------------------------------------------------------

            OPEN(LUNIN,FILE=FILENAME(1:NBYTES_FILE),FORM='UNFORMATTED')
            IF(NREP.GT.0)  THEN

C    COUNT THE NUMBER OF SUBSETS IN THE FILE TO ALLOCATE SPACE
C    ---------------------------------------------------------

               CALL UFBTAB(-LUNIN,UFBTAB_8,1,1,MXTB,' ')

               IF(SAT)  THEN

C       SATELLITES TYPES COME HERE
C       --------------------------

                  IF(ISATF.GT.0) THEN
                     DEALLOCATE(SAID_8,STAT=I);IF(I.NE.0) GOTO 901
                     DEALLOCATE(SAID,STAT=I);IF(I.NE.0) GOTO 901
                  ENDIF
                  ALLOCATE(SAID_8(MXTB),STAT=I);IF(I.NE.0) GOTO 900
                  ALLOCATE(SAID(MXTB),STAT=I);IF(I.NE.0) GOTO 900
                  ISATF = ISATF + 1

                  OPEN(LUNIN,FILE=FILENAME(1:NBYTES_FILE),
     .             FORM='UNFORMATTED')

                  CALL UFBTAB(LUNIN,SAID_8,1,MXTB,NTAB,'SAID')
                  SAID=SAID_8
                  IF(NTAB.GT.0)  THEN
                     DO I=1,NTAB
                       IF(NINT(SAID(I)).GT.1023)  SAID(I) = 1023.
                       KOUNT(NINT(SAID(I))) = KOUNT(NINT(SAID(I))) + 1
                     ENDDO
                     DO I=1,1023  ! ready to print counts by sat. id
                        IF(KOUNT(I).GT.0)  PRINT'(9X,"---> ",A7," (in ",
     .                   A6,'//'") SAT. ID",I5," has ",I8," reports")',
     .                   FILENAME(JJJ-3:JJJ+3),GROUP(1:6),I,KOUNT(I)
                         IFLAG = 1
                     ENDDO
                     IF(IFLAG.EQ.1)  PRINT'(69X,"%#")' ! mrkr used later
                                                       !  to write cnts
                                                       !  to status file
                  ENDIF
               ELSE IF(RADAR_L2) THEN

C       LEVEL 2 AND TDR RADAR TYPES COME HERE
C       -------------------------------------

                  IF(IRAD2F.GT.0) THEN
                     DEALLOCATE(TAB_8,STAT=I);IF(I.NE.0) GOTO 901
                     DEALLOCATE(TAB,STAT=I);IF(I.NE.0) GOTO 901
                  ENDIF
                  ALLOCATE(TAB_8(MXTB),STAT=I);IF(I.NE.0) GOTO 900
                  ALLOCATE(TAB(MXTB),STAT=I);IF(I.NE.0) GOTO 900
                  IRAD2F = IRAD2F + 1

                  OPEN(LUNIN,FILE=FILENAME(1:NBYTES_FILE),
     .             FORM='UNFORMATTED')

                  IF(FILENAME(JJJ+1:JJJ+3).GE.'010' .AND.
     .               FILENAME(JJJ+1:JJJ+3).LE.'033') THEN
                     CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(NL2RW)')
                  ELSE IF(FILENAME(JJJ+1:JJJ+3).GE.'040' .AND.
     .                    FILENAME(JJJ+1:JJJ+3).LE.'063') THEN
                      CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(NL2RF)')
                  ELSE IF(FILENAME(JJJ+1:JJJ+3).EQ.'070') THEN
                      CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(NP3RW)')
                  ENDIF
                  TAB=TAB_8
                  IF(NTAB.GT.0)  THEN
                     DO I=1,NTAB
                       ICOUNT2 = ICOUNT2 + NINT(TAB(I))
                     ENDDO
                  ENDIF
                  IF(ICOUNT2.GT.0)  PRINT'(9X,"---> ",A7," (in ",A6,'//
     .             '") has ",I11," replicated observations")',
     .             FILENAME(JJJ-3:JJJ+3),GROUP(1:6),ICOUNT2
                   ICOUNT2 = 0
                   PRINT'(69X,"#%")' ! marker used later to write counts
                                     !  to status file
               ELSE IF(RADAR) THEN

C       LEVEL 2.5/3 RADAR TYPES COME HERE
C       ---------------------------------

                  IF(IRADF.GT.0) THEN
                     DEALLOCATE(TAB_8,STAT=I);IF(I.NE.0) GOTO 901
                     DEALLOCATE(TAB,STAT=I);IF(I.NE.0) GOTO 901
                  ENDIF
                  ALLOCATE(TAB_8(MXTB),STAT=I);IF(I.NE.0) GOTO 900
                  ALLOCATE(TAB(MXTB),STAT=I);IF(I.NE.0) GOTO 900
                  IRADF = IRADF + 1

                  OPEN(LUNIN,FILE=FILENAME(1:NBYTES_FILE),
     .             FORM='UNFORMATTED')

                  IF(FILENAME(JJJ+1:JJJ+3).LE.'002') THEN
                     CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(RWSOB)')
                  ELSE IF(FILENAME(JJJ+1:JJJ+3).GE.'010' .AND.
     .                    FILENAME(JJJ+1:JJJ+3).LE.'033') THEN

C           CURRENTLY CAN NEVER GET HERE BECAUSE RADAR=F FOR L2 R. WIND
C           -----------------------------------------------------------

                     CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(NL2RW)')
                  ELSE IF(FILENAME(JJJ+1:JJJ+3).GE.'040' .AND.
     .                    FILENAME(JJJ+1:JJJ+3).LE.'063') THEN

C           CURRENTLY CAN NEVER GET HERE BECAUSE RADAR=F FOR L2 REFL.
C           ---------------------------------------------------------

                     CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(NL2RF)')
                  ELSE IF(FILENAME(JJJ+1:JJJ+3).EQ.'070') THEN

C           CURRENTLY CAN NEVER GET HERE BECAUSE RADAR=F FOR TDR R. WIND
C           ------------------------------------------------------------

                     CALL UFBTAB(LUNIN,TAB_8,1,MXTB,NTAB,'(NP3RW)')
                  ENDIF
                  TAB=TAB_8
                  IF(NTAB.GT.0)  THEN
                     DO I=1,NTAB
                        ICOUNT = ICOUNT + NINT(TAB(I))
                     ENDDO
                  ENDIF
                  IF(ICOUNT.GT.0) THEN ! primary print is # of repl. obs
                                       ! secondary print is # of subsets
                     PRINT'(A7,"  HAS ",I8," REPORTS")',
     .                FILENAME(JJJ-3:JJJ+3),ICOUNT
                     PRINT'("     ... obtained from ",I8," SUBSETS")',
     .                NREP
                  ELSE  !  this should never happen!
                     PRINT'(A7,"  HAS ",I8," REPORTS")',
     .                FILENAME(JJJ-3:JJJ+3),NREP
                  ENDIF
               ENDIF
            ELSE IF(RADAR) THEN

C    COME HERE IF FILE EMPTY OR HAD NO DATA MSGS (RADAR LVL 2.5/3 ONLY)
C    ------------------------------------------------------------------
               PRINT'(A7,"  HAS ",I8," REPORTS")',FILENAME(JJJ-3:JJJ+3),
     .          NREP
            ENDIF
         ENDIF

      ENDDO

    3 CONTINUE
 
C  EXIT THE PROGRAM WITH A RETURN CODE AS DESCRIBED ABOVE
C  ------------------------------------------------------
 
      write(60,'("ALL DONE")')  ! write good completion to status file
                                !  read by dumpjb
      IF(SOME.AND..NOT.NONE ) THEN
         CALL W3TAGE('BUFR_CHKBFR')
         STOP
      ELSE IF(SOME.AND.     NONE ) THEN
         CALL W3TAGE('BUFR_CHKBFR')
         CALL ERREXIT(11)
      ELSE IF(NONE.AND..NOT.SOME ) THEN
         CALL W3TAGE('BUFR_CHKBFR')
         CALL ERREXIT(22)
      ELSE IF(.NOT.(SOME.OR.NONE)) THEN
         CALL W3TAGE('BUFR_CHKBFR')
         CALL ERREXIT(22)
      ENDIF

C  END OF PROGRAM
C  --------------

      CALL W3TAGE('BUFR_CHKBFR')
      STOP

C  ERROR EXITS
C  -----------

900   CONTINUE

      PRINT *, '#####BUFR_CHKBFR - UNABLE TO ALLOCATE ARRAYS'
      CALL W3TAGE('BUFR_CHKBFR')
      CALL ERREXIT(99)

901   CONTINUE

      PRINT *, '#####BUFR_CHKBFR - UNABLE TO DEALLOCATE ARRAYS'
      CALL W3TAGE('BUFR_CHKBFR')
      CALL ERREXIT(99)

      END

