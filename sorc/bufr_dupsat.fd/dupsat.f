C$$$  MAIN PROGRAM DOCUMENTATION BLOCK
C
C MAIN PROGRAM: BUFR_DUPSAT
C   PRGMMR: DONG                    ORG: NP22        DATE: 2021-09-02
C
C ABSTRACT: PROCESSES SATELLITE DATABASE REPORTS WITH (OPTIONAL)
C   GEOGRAPHICAL FILTERING, DUPLICATE CHECKING, (OPTIONAL) TRIMMING
C   TO EXACT TIME WINDOW (DAY DOWN TO SECOND) AND CORRECTING OF
C   LONGITUDE TO BUFR STANDARD (I.E., CHANGE 0 --> 360 E TO
C   -180 --> +180, E+,W-) (IF NECESSARY).  AN UPDATED REPORT ID
C   (MNEMONIC "RPID") IS ALSO GENERATED FOR DERIVED WINDS FROM GOES-15 &
C   DOWN, METEOSAT, INSAT, KALPANA, GMS, MTSAT, HIMAWARI, AQUA/TERRA
C   (POES), NOAA/METOP (POES), NPP (POES) AND NESDIS RETRIEVALS AND
C   PROCESSED RADIANCES FROM GOES. OTHER RPT TYPES (WHICH GET ONLY DUP
C   CHECKING, OPTIONAL GEOGRAPHICAL FILTERING, OPTIONAL TIME WINDOW
C   TRIMMING AND POSSIBLE LONGITUDE CORRECTION) INCLUDE NESDIS
C   RETRIEVALS AND PROCESSED RADIANCES FROM TOVS, RTOVS, ATOVS AND AVHRR
C   (INCLUDING 1B RADIANCES); AQUA/AIRS (CENTER, WARMEST AND EVERY
C   F-O-V), AMSRE RADIANCES AND METOP/IASI RADIANCES; AND PRODUCTS AND
C   RADIANCES FROM ERS, SSM/I, QUIKSCAT, WINDSAT, ASCAT, TRMM AND GPS.
C   THE ATOVS 1B RADIANCES ARE AVAILABLE VIA ORBITAL DOWNLOAD FROM THE
C   SPACECRAFT, AS WELL AS FROM THE REGIONAL ATOVS RETRANSMISSION
C   SERVICES (RARS) VIA DIRECT TRANSMISSION OF DATA TO A NETWORK OF
C   GROUND STATIONS (IN NEAR REAL-TIME). FOR ALL TYPES EXCEPT SSM/I, THE
C   ALGORITHM SORTS THE REPORTS IN ASCENDING ORDER OF LAT, LON AND OBS
C   TIME (DAY DOWN TO SECOND); AND IN THE DUPLICATE CHECKING, REPORTS
C   ARE CHECKED FOR LAT, LON AND OBS TIME (DAY DOWN TO SECOND) ALL
C   INSIDE THE TOLERANCE LIMITS.  FOR SSM/I, LAT IS REPLACED BY ORBIT
C   NUMBER AND LON IS REPLACED BY SCAN NUMBER IN BOTH THE SORTING AND
C   DUPLICATE CHECKING STEPS (LONGITUDE IS STILL CORRECTED TO BUFR
C   STANDARD IF NECESSARY).  THE FILE PATH/NAMES OF THE INPUT AND OUTPUT
C   FILES, (OPTIONALLY) THE TIME WINDOW TO TRIM TO AND (OPTIONALLY)
C   DEFAULT OVERRIDE DUP CHECKING TOLERANCE LIMITS ARE READ FROM
C   STANDARD INPUT AT THE START OF THIS PROGRAM.  IF THE TIME WINDOW
C   RECORD IS MISSING, THEN NO TIME WINDOW TRIMMING IS PERFORMED.  THE
C   GEOGRAPHICAL FILTERING PARAMETERS (EITHER A LAT/LON BOUNDARY, A
C   CENTER POINT LAT/LON AND RADIUS OR A 0.5 DEGREE GLOBAL LAT/LON GRID
C   POINT MASK FILE) ARE READ IN FROM THE SCRIPT ENVIRONMENT VARIABLE
C   "LALO" VIA THE SYSTEM LIBRARY ROUTINE "GETENV" (IF "LALO" IS MISSING
C   OR "0", GEOGRAPHICAL FILTERING IS NOT PERFORMED).  ALL FILE
C   CONNECTIONS (EXCEPT STANDARD INPUT WHICH IS PRE-CONNECTED) ARE MADE
C   THROUGH THE FORTRAN OPEN STATEMENT.
C
C PROGRAM HISTORY LOG:
C 1996-09-06  J. WOOLLEN  ORIGINAL VERSION FOR IMPLEMENTATION
C 1998-03-27  BERT KATZ   ADDED NEURAL NET SSM/I TANK PROCESSING
C 1998-12-02  J. WOOLLEN  Y2K/F90 COMPLIANT
C 1999-06-03  D. KEYSER   MODIFIED TO PORT TO IBM SP AND RUN IN 4 OR
C     8 BYTE STORAGE
C 2000-04-11  BERT KATZ   INCREASED MXTB FROM 500000 TO 800000 TO
C     HANDLE LARGE VOLUME QUIKSCAT PROCESSING
C 2000-12-05  D. KEYSER   INCREASED LIMIT FOR I/O FILENAME LENGTH
C     FROM 80 CHARACTERS TO 500 CHARACTERS; ADDED SUBROUTINE SATWND_ID
C     TO UPDATE SATELLITE-DERIVED REPORT IDS; ADDED SUBROUTINE
C     GOESND_ID TO UPDATE GOES SOUNDING REPORT IDS
C 2001-04-06  D. KEYSER   MODIFIED SUBR. SATWND_ID TO HANDLE NEW
C     BUFR EUMETSAT WINDS IN SUBSETS "NC005064", "NC005065" AND
C     "NC005066"
C 2001-04-25  D. KEYSER   CORRECTED ERROR WHICH RESULTED IN A FAILURE
C     TO COPY MESSAGE 2 (EMPTY, CONTAINING DUMP TIME IN SECTION 1) TO
C     OUTPUT FILE FOR SATELLITE-DERIVED WIND AND GOES SOUNDING DATA
C     TYPES WHEN THE DUMP HOUR IS THE SAME AS THE CENTER TIME HOUR IN
C     MESSAGE 1
C 2001-06-19  D. A. KEYSER -- RECOGNIZES BUFR TYPE/SUBTYPE 003/002 AS
C     GOES 1x1 (HI-RES) DATA, PART OF THE "GOESND" DUMP FILE; GOES
C     HI-RES REPORTS HAVE UNKNOWN PATH AND GET PROPER STNID CHAR. 8
C     CHARACTER IDENTIFYING THE SAT. NUMBER AND GET "H" IN STNID CHAR.
C     1 TO UNIQUELY IDENTIFY THEM
C 2001-07-20  D. A. KEYSER -- INCREASED MXTB FROM 800000 TO 2400000
C     TO HANDLE LARGE VOLUME GOES SFOV CLOUD-TOP PROCESSING
C 2001-10-01  D. A. KEYSER -- INCREASED MXTB FROM 2400000 TO 3600000
C     TO HANDLE LARGE VOLUME GOES SFOV CLOUD-TOP PROCESSING
C 2002-03-05  D. A. KEYSER -- IMPROVED DOCUMENTATION; IMPROVED STANDARD
C     OUTPUT PRINT; MADE TIME CHECK MORE PRECISE BY INCLUDING SECONDS
C     (MISSING SECONDS SET TO ZERO); ADDED CALL TO COMPRESS_CHECK TO
C     INDICATE IF INPUT/OUTPUT FILES ARE COMPRESSED OR UNCOMPRESSED
C 2003-05-23  D. A. KEYSER -- GOES-9 (SAT. ID 253) WINDS WITH BUFR
C     MESSAGE SUBTYPE 41-43 ALWAYS GET "P" IN 1ST CHAR. OF STN. ID AND
C     "D" (PROCUCER = JMA) IN 2ND CHAR. OF STN. ID. (JMA BEGAN
C     PRODUCING WINDS FROM GOES-9 IN PLACE OF FAILING GMS-5 ON
C     23 MAY 2003), WHEN NESDIS PRODUCES WINDS FROM GOES-9 THE FIRST
C     CHAR. IN THE STN. ID IS "C" (AS BEFORE)
C 2004-02-02  D. KEYSER   MODIFICATIONS TO PREVENT ARRAY OVERFLOW WHEN
C     THERE ARE > MXTB REPORTS; IMPROVED DIAGNOSTIC PRINT; REPLACED CALL
C     TO IN-LINE SUBROUTINE COMPRESS_CHECK WITH CALL TO NEW BUFRLIB
C     ROUTINE MESGBC; ADDED LOGIC TO HANDLE FUTURE NASA/MODIS (AQUA/
C     TERRA) POES WINDS AND GTS NESDIS GOES WINDS IN SATWND_ID
C 2005-03-14  D. KEYSER   CHANGES IN SUBR. SATWND_ID IN RESPONSE TO
C     NESDIS' CORRECTION OF AN ERROR (EFF. 3/10/2005) WHICH HAD STORED
C     SIDP (SATELLITE INSTRUMENT USED IN DATA PROCESSING) AS A CODE
C     TABLE VALUE RATHER THAN CORRECTLY AS A FLAG TABLE VALUE (THE
C     CHANGE BY NESDIS RESULTED IN INSTRUMENT TYPE BEING STORED AS
C     MISSING AND THE REPORT ID NOT BEING INDEXED) (WILL STILL WORK OK
C     FOR HISTORICAL RUNS PRIOR TO NESDIS FIX)
C 2005-07-20  D. KEYSER   CHANGES IN SUBR. SATWND_ID IN RESPONSE TO
C     JMA'S SWITCH FROM GOES-9 (SATELLITE ID 253) TO NEW MTSAT-1R
C     (SATELLITE ID 171) ON 7/15/2005, FIRST CHARACTER OF RPID IS "Q"
C     FOR MTSAT-1R
C 2005-10-19  J. WOOLLEN  INTRODUCED ALLOCATABLE ARRAYS TO AVOID ARRAY
C     OVERFLOW PROBLEMS, DETERMINES SIZE OF ARRAYS BY CALLING UFBTAB
C     WITH NEGATIVE UNIT NUMBER TO SIMPLY COUNT SUBSETS; ENABLED
C     CAPACITY TO PROCESS COMPRESSED BUFR MESSAGES, DONE THROUGH
C     TEMPORARY IN-LINE VERSIONS OF BUFRLIB ROUTINES UFBTAB AND COPYSB
C     WHICH CAN NOW HANDLE COMPRESSED MESSAGES (THESE WILL BE
C     IMPLEMENTED IN NEXT VERSION OF BUFRLIB AFTERWHICH THEY SHOULD BE
C     REMOVED HERE), THIS ALLOWS TYPES SUCH AS ATOVS AND AVHRR 1B
C     RADIANCES AND CENTER F-O-V AIRS AND AMSRE RADIANCES TO NOW BE
C     PROCESSED HERE {THESE HAD BEEN DUP-CHECKED BY PROGRAM BUFR_DUPS1B]
C     IN A MUCH SLOWER (COMPUTATIONALLY) HASH PROCESSING}; ADDED
C     SPECIAL MNEMONIC STRING FOR PROCESSING CENTER F-O-V AIRS DATA
C     (CLATH AND CLONH REPLACE CLAT AND CLON, RESP.); MODIFIED STREAM
C     WHICH BRANCHES OFF TO PERFORM ID PROCESSING OF SATELLITE WIND AND
C     GOES SOUNDING REPORTS (TO INCREASE EFFICIENCY)
C 2005-10-19  D. KEYSER   IF TIME WINDOW RECORD (LINE 3) IS EMPTY IN
C     STANDARD INPUT, TIME WINDOW TRIMMING LOOP BYPASSED, BASED ON
C     TEST FOR DEFAULT VALUE OF LATEST REQUESTED DATE WHICH IS NOW
C     CORRECTED TO BE 99999999.00_8 (WAS 99999999.00 BUT IN 4-BYTE REAL
C     MACHINES THIS COULD BE ROUNDED UP TO 100000000.00 MEANING LASTEST
C     DDHH.hh IN TIME TESTS, BEFORE TIME WINDOW TRIMMING LOOP WAS
C     BYPASSED, WOULD BE 0000 AND ALL REPORTS WOULD BE TRIMMED RATHER
C     THAN RETAINED); REPORTS ARE NOW DUP-CHECKED TO NEAREST .00001
C     SECOND RATHER THAN TO NEAREST 0.01 SECOND BECAUSE FUTURE AVHRR
C     DATA WILL BE AVAILABLE TO AT LEAST 0.1 MILLISECOND PRECISION,
C     ALSO EXISTING RARS DATA ARE STORED TO NEAREST MILLISECOND; ADDED
C     CHECK FOR MISSING LAT/LON; ATOVS HIRS-2 1B BRIGHTNESS TEMPS ARE
C     GROSS CHECKED IN NEW SUBR. "HIRS2", REPORTS WITH MISSING CHN. 8
C     BRIGHTNESS TEMP ARE TOSSED (MEANS ALL BRIGHTNESS TEMPS ARE
C     MISSING), THIS HAD BEEN DONE IN PROGRAM BUFR_DUPS1B; MODIFIED TO
C     HANDLE "RARS" REPORTS, SKIPPING OVER ALL WITH BIT 6 SET IN SCAN
C     LINE QUALITY FLAGS BECAUSE THEY OFTEN DUPLICATE (IN TIME/SPACE)
C     REPORTS WITH "GOOD" SCAN LINE QUALITY, THIS PREVENTS CODE FROM
C     SELECTING THE GOOD REPORT AS THE DUPLICATE TO TOSS (SEE COMMENTS
C     IN CODE FOR MORE INFORMATION); RARS, WARMEST F-O-V AIRS AND
C     AMSR-E WILL USE SAME SPECIAL MNEMONIC STRING ADDED EARLIER FOR
C     PROCESSING CENTER F-O-V AIRS DATA (CLATH AND CLONH REPLACE CLAT
C     AND CLON, RESP.); ADDED OPTIONAL GEOGRAPHICAL FILTERING AND
C     ASSOCIATED SUBROUTINE CHDIST (AS HAD BEEN DONE IN PROGRAM
C     BUFR_DUPS1B)
C 2006-03-02  D. KEYSER   CHECKS TO SEE IF INPUT BUFR FILE CONTAINS
C     "DUMMY" MESSAGES CONTAINING DUMP CENTER TIME AND PROCESSING TIME,
C     RESP. IN FIRST TWO MESSAGES OF INPUT FILE (AFTER TABLE MSGS) BY
C     CHECKING THE VALUE OF DUMPJB SCRIPT VARIABLE "DUMMY_MSGS" (READ
C     IN VIA "GETENV") - IF NOT WILL NOT COPY THE FIRST TWO MESSAGES
C     READ IN TO THE OUTPUT FILE, WILL NOT PROCESS INPUT BUFR MESSAGES
C     WITH ZERO SUBSETS, BUT WILL CALL BUFRLIB ROUTINE CLOSMG WITH A
C     NEGATIVE UNIT NUMBER ARGUMENT PRIOR TO ALL PROCESSING IN ORDER TO
C     SIGNAL IT THAT ANY OUTPUT BUFR MESSAGES WITH ZERO SUBSETS SHOULD
C     BE SKIPPED (NOT WRITTEN OUT) - CODE HAD BEEN HARDWIRED TO ALWAYS
C     ASSUME DUMMY MESSAGES WERE IN THE INPUT FILE, COPYING THE FIRST
C     TWO MESSAGES DIRECTLY TO THE OUTPUT FILE; NOW EXPECTS AVHRR DATA
C     TO HAVE HI-RES LAT/LON (CLATH/CLONH) INSTEAD OF LO-RES LAT/LON
C     (CLAT/CLON); ALL REPORTS ARE NOW DUP-CHECKED TO NEAREST .00001
C     LAT/LON RATHER THAN NEAREST .01 LAT/LON TO ACCOUNT FOR TYPES WITH
C     HI-RES LAT/LON; REMOVES IN-LINE VERSIONS OF UFBTAB AND COPYSB
C     (UPDATED TO HANDLE COMPRESSED BUFR MESSAGES IN 1/31/2006 VERSION
C     OF BUFRLIB); UPDATED TO HANDLE GPS-RO DATA {HAVE HI-RES LAT/LON
C     (CLATH/CLONH)}; UPDATED TO HANDLE NEW INDIAN SATELLITES KALPANA-1
C     (SAT. ID 440, GETS STN. ID PREFIX CHARACTER "K") AND INSAT-3A
C     (SAT. ID 470, GETS STN. ID PREFIX CHARACTER "V")
C 2006-12-06  D. KEYSER   CAN NOW PROCESS AIRS EVERY F-O-V DATA IN
C     SUBSET "NC021249" AND GOES SFOV (1x1) SOUNDING/RADIANCE DATA IN
C     SUBSET "NC003003"
C 2007-03-23  D. KEYSER   CORRECTED METHOD OF CALLING UFBTAB WITH
C     NEGATIVE UNIT NUMBER TO COUNT SUBSETS FOR USE WITH EXISTING
C     ALLOCATABLE ARRAYS, PREVIOUS LOGIC COULD HAVE LEAD TO ARRAY
C     OVERFLOW PROBLEMS - STREAMLINED THIS LOGIC AS WELL
C 2007-06-13  D. KEYSER   GENERALIZED CODE TO FIRST CHECK ALL TYPES FOR
C     LOW-RES LAT/LON (VIA FIRST REPORT) AND IF NOT FOUND ASSUME TYPE
C     STORES HIGH-RES LAT/LON (BEFORE LOW- VS. HIGH-RES LAT/LON WAS
C     DECIDED EXPLICITLY BY DATA TYPE, WITH ANY NEW TYPES DEFAULTING TO
C     LOW-RES LAT/LON WHICH WAS NOT ALWAYS CORRECT THUS NECESSITATING
C     AN UPDATE TO THIS CODE);  ADDED NEW OPTION TO FILTER VIA THE USE
C     OF A 0.5 DEGREE GLOBAL LAT/LON GRID POINT MASK FILE (SEE REMARKS
C     FOR MORE INFORMATION); ADDED CHECK FOR UNREASONABLE LAT/LON
C 2007-11-02  D. KEYSER   CORRECTS LONGITUDE TO BUFR STANDARD (I.E.,
C     CHANGES 0 --> 360 E TO -180 --> +180, E+,W-) (IF NECESSARY) AND
C     POSTS A WARNING MESSAGE TO THE PRODUCTION JOBLOG PRIOR TO
C     ENCODING LONGITUDE INTO OUTPUT FILE, BEFORE ALL SUCH OBS WERE
C     TOSSED DUE TO 2007-06-13 CHANGE TO ADD CHECK FOR UNREASONABLE
C     LAT/LON, MEANWHILE PRIOR TO 2007-06-13 CHANGE ALL SUCH OBS WERE
C     RETAINED BUT WITH NON-BUFR STANDARD LONGITUDE; TEST FOR LAT/LON
C     TYPE (HIGH-RES OR LOW-RES) NOW LOOPS THROUGH UP TO FIRST 25
C     REPORTS LOOKING FOR FIRST REPORT WITH EITHER A NON-MISSING HIGH-
C     RES LATITUDE OR A NON-MISSING LOW-RES LATITUDE - THIS THEN
C     DETERMINES IF THIS REPORT TYPE ENCODES LOW- OR HIGH-RES LAT/LON,
C     BEFORE ALWAYS ASSUMED A REPORT TYPE'S LAT/LON WAS HIGH-RES IF
C     FIRST REPORT'S LOW-RES LATITUDE WAS MISSING, A PROBLEM IF THE
C     FIRST FEW REPORTS IN A LOW-RES LAT/LON REPORT TYPE JUST HAPPEN TO
C     HAVE MISSING LATITUDES BUT ALL OTHERS ARE VALID (NOTE: POSTS A
C     WARNING MESSAGE TO THE PRODUCTION JOBLOG IF FIRST 1 OR MORE
C     REPORTS HAVE A MISSING LATITUDE)
C 2010-04-29  D. KEYSER   CALL MAXOUT TO INCREASE SIZE OF OUPUT BUFR
C     MESSAGES FROM 10K (DEFAULT) TO 25K (NEEDED FOR SOME SATELLITE
C     TYPES WHICH ARE COMING IN WITH 20-25K MESSAGE LENGTHS AND MAY
C     HAVE SUBSETS > 10K (E.G., GPSRO); IN PREPARATION FOR FUTURE
C     NEW BUFRLIB WHICH CAN HANDLE EMBEDDED DICTIONARY MESSAGES,
C     INCREASES AMOUNT OF BUFRLIB PRINTOUT DURING (ONLY) THE POINT WHEN
C     READING IN MESSAGES IN ORDER TO DETECT ANY EMBEDDED DICTIONARY
C     MESSAGES
C 2010-05-26  D. KEYSER   ACCOUNTS FOR NEW EARS MHS TANK (IN NC021036);
C     CORRECTS AN OVERSIGHT AND NOW INCLUDES LAST SUBSET IN SORTED LIST
C     IN TESTS FOR MISSING OR UNREASONABLE LAT OR LON, BAD SCAN LINE
C     CALIBRATION (RARS ONLY), AND LAT/LON OUTSIDE GEOGRAPHICAL DOMAIN
C     (NON-GLOBAL DUMPS ONLY) (ESPECIALLY IMPORTANT WHEN LAT IS MISSING
C     SINCE FIRST SORT KEY IS LAT AND MISSING VALUES THUS END UP AT END
C     OF SORTED LIST)
C 2010-09-30  D. KEYSER   CHANGES IN RESPONSE TO JMA'S SWITCH FROM
C     MTSAT-1R (SATELLITE ID 171) TO NEW MTSAT-2 (SATELLITE ID 172) ON
C     8/11/2010, FIRST CHARACTER OF RPID IS "R" FOR MTSAT-2; UPDATED TO
C     ACCOUNT FOR FUTURE SATELLITE IDS (E.G., METOP AND NOAA FOR
C     FUTURE AVHRR WINDS, FUTURE JMA AND EUMETSAT SATELLITES)
C 2011-07-15  D. KEYSER   CORRECTED BUG WHICH LED TO CHARACTERS 3-7 OF
C     GENERATED RPID BEING "?????" (RATHER THAN AN INCREMENTED COUNT)
C     FOR MODIS (AQUA/TERRA) IR AND WV WIND REPORTS (OCCURRED AFTER
C     NESDIS MADE CHANGE IN SPRING 2010 TO CORRECTLY DESIGNATE THESE AS
C     POES IMAGER WINDS RATHER THAN AS GEOSTATIONARY IMAGER WINDS);
C     MORE CHANGES MADE TO PROPERLY HANDLE FUTURE AVHRR POES WINDS; THE
C     LONGITUDE CORRECTION CHANGE FROM 2007-11-02 IS UPDATED AS
C     FOLLOWS: 1) IT WILL NOT BE PERFORMED IF THE CORRESPONDING
C     LATITUDE IS UNREASONABLE, 2) THE OUTPUT FILE WILL BE IN THE SAME
C     BUFR COMPRESSION STATE AS THE INPUT FILE (RATHER THAN ALWAYS
C     UNCOMPRESSED); FOR THOSE TYPES FOR WHICH THE REPORT ID IS
C     UPDATED HERE (I.E., GOES SOUNDINGS, SATELLITE WINDS), THE OUTPUT
C     FILE WILL NOW BE IN THE SAME BUFR COMPRESSION STATE AS THE INPUT
C     FILE (RATHER THAN ALWAYS UNCOMPRESSED) (NOTE: CURRENTLY THESE
C     TYPES ALWAYS COME IN AS UNCOMPRESSED SO THIS WOULD ONLY AFFECT
C     FUTURE FILES FOR THESE TYPES WHICH MIGHT COME IN AS COMPRESSED
C     BUFR); FOR ATOVS HIRS-2 DATA FOR WHICH BRIGHTNESS TEMPS ARE GROSS
C     CHECKED HERE, THE OUTPUT FILE WILL NOW BE IN THE SAME BUFR
C     COMPRESSION STATE AS THE INPUT FILE (RATHER THAN ALWAYS
C     COMPRESSED) (NOTE: CURRENTLY THIS TYPE IS NOT USED, BUT IT HAD
C     ALWAYS COME IN AS COMPRESSED, SO THIS CHANGE WOULD NOT AFFECT ANY
C     RETROSPECTIVE RUNS); THE DEFAULT TOLERANCE FOR LAT/LON CHECKS OF
C     ATOVS 1B REPORTS (ONLY) IS CHANGED FROM 0.00 TO 0.01 DEGREES TO
C     ENSURE THAT ALL DUPLICATE REPORTS IN OVERLAPPING ORBITAL FILES
C     PULLED FROM DDS ARE TOSSED (THESE CAN SOMETIMES HAVE LAT/LON
C     VALUES DIFFERING BY AS MUCH AS 0.01 DEGREES DUE TO DIFFERENCES IN
C     POES GROUND SYSTEM PROCESSING, THEIR TIMES ARE ALWAYS THE SAME TO
C     THE SECOND); A CHECK IS ADDED TO SEE IF DUPLICATE REPORTS HAVE
C     DIFFERENT SATELLITE IDS, IF SO A DIAGNOSTIC IS PRINTED (WE MAY
C     NOT WANT TO TOSS DUPLICATE REPORTS WITH DIFFERENT SATELLITE IDS,
C     IF INDEED THERE EVER ARE ANY, IN THE FUTURE)
C 2012-11-20  J. WOOLLEN  INITIAL PORT TO WCOSS -- ADAPTED IBM/AIX
C       GETENV SUBPROGRAM CALLS TO INTEL/LINUX SYNTAX
C 2013-01-14  J. WHITING  FINAL PORT TO WCOSS -- UPDATED DOC BLOCKS;
C       REPLACED TESTS VS BMISS W/ IBFMS FUNCTION; REPLACED EXPLICIT
C       ASSIGNMENT OF BMISS W/ GETBMISS() FUNCTION.
C 2013-07-01  D. KEYSER   ADDED GOES-15 (SAT. ID 259) TO COMMENTS
C 2014-11-07  D. KEYSER   DECLARE FUNCTION GETBMISS AND ITS RETURN
C     VALUE BMISS AS REAL*8 TO GET A RELIABLE VALUE FOR BMISS IN PRINT
C     STATEMENTS
C 2015-01-28  D. KEYSER
C     In subr. SATWND_ID:
C      - IR (long-wave) NPP VIIRS POES winds now handled. These have
C        message type NC005090 and BUFR satellite ID 224. Get
C        previously unused character "J" in 1st character of generated
C        RPID and "9" (meaning NASA is producer) in 2nd character of
C        RPID.
C      - IR (short-wave) GOES winds now handled. These have message
C        type NC0050019.  Get previously unused character "S" in 8th
C        character of generated RPID. New instrument/product type (ITP)
C        19 is defined for IR short-wave imager automated winds. This
C        allows a unique sequential serial index (counter) to be used
C        to generate characters 3-7 of RPID for each individual
C        satellite.
C 2015-06-30  D. Keyser  Fixed bug in code which failed to initialize a
C        counting variable and led to incorrect print statements. It
C        had no affect on answers.
C 2018-03-28  D. Keyser  Changes to handle new GOES-16 & up satellite
C        winds which do not contain a report id (RPID) - do not call
C        subroutine SATWND_ID for these.
C 2019-04-16  S. MELCHIOR  In subr. SATWND_ID: IR (long-wave) NOAA-20
C        VIIRS POES winds now handled. These have message type NC005090
C        and BUFR satellite ID 225. Get previously unused character "S"
C        in 1st character of generated RPID and "9" (meaning NASA is
C        producer) in 2nd character of RPID.
C 2020-08-20  J. DONG   ADDED SETBMISS CALL TO SET BMISS TO 10E8 AND
C        CHANGE THE CODE TO FIX OUTPUT CONVERSION ERROR
C 2021-09-02  D. STOKES -- COMMENTED SYSTEM CALLS OF POSTMSG TO JLOGFILE
C
C USAGE:
C   INPUT FILES:
C     UNIT 05  - STANDARD INPUT - FIRST RECORD CONTAINS INPUT FILE
C                NAME, SECOND RECORD CONTAINS OUTPUT FILE NAME,
C                OPTIONAL THIRD RECORD CONTAINS TIME WINDOW TRIMMING
C                SPECIFICATIONS (THE YYYYMMDDHH<.HH> DATE OF THE
C                EARLIEST TIME TO DUMP AND THE YYYYMMDDHH<.HH> DATE OF
C                THE LATEST TIME TO DUMP), OPTIONAL FOURTH RECORD
C                CONTAINS DUP-CHECKING TOLERANCE LIMITS (IF FOURTH
C                RECORD IS MISSING, DEFAULT DUP-CHECKING TOLERANCE
C                LIMITS ARE USED, IF THIRD RECORD IS ALSO MISSING, NO
C                TIME WINDOW TRIMMING IS PERFORMED)
C     UNIT 20  - UNCHECKED, UNWINDOWED AND UNFILTERED BUFR DUMP FILE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C     UNIT 50  - DUPLICATE-CHECKED, (OPTIONAL) TIME-WINDOW-TRIMMED,
C                (OPTIONAL) GEOGRAPHICALLY-FILTERED AND POSSIBLY
C                LONGITUDE-CORRECTED BUFR DUMP FILE
C
C   SUBPROGRAMS CALLED:
C     UNIQUE     - GOESND_ID  SATWND_ID  HIRS2  CHDIST  GEOCHK
C     LIBRARY:
C       SYSTEM   - DATE_AND_TIME  SYSTEM GETENV
C       W3NCO    - W3TAGB  W3TAGE ERREXIT
C       W3EMC    - ORDERS 
C       BUFRLIB  - DATELEN OPENBF COPYMG UFBINT UFBCPY OPENMB WRITSB
C                  COPYSB  UFBTAB CLOSMG CLOSBF MESGBC UFBREP WRITCP
C                  MAXOUT  IBFMS  GETBMISS
C
C   EXIT STATES:
C     COND =   0 - SUCCESSFUL RUN
C            > 0 - ABNORMAL RUN
C
C REMARKS: CONTENTS OF SCRIPT ENVIRONMENT VARAIBLE "LALO" READ IN VIA
C           SYSTEM LIBRARY ROUTINE "GETENV" (GEOGRAPHICAL FILTERING
C           PARAMETERS):
C      If "F<file name>":
C          the presence of the character "F" is position 1 indicates a
C          lat/lon grid point mask file identified by the full path
C          name in characters 2-end -
C           the characteristics of the mask are:
C             full global lat/lon
C             grid spacing is 0.5 deg
C             mask is integer*4 with dimension mask(720,361)
C                 mask(1,1) is at 0.0 E lon, 90.0 S lat
C                 mask(720,1) is at 359.5 E lon, -90.0 S lat
C                 mask(1,361) is at 0.0 E lon, 90.0 N lat
C                 mask(720,361) is at 359.5 E lon, 90.0 N lat
C             mask(i,j) = 0 --> grid point is outside domain
C             mask(i,j) = 1 --> grid point is inside domain
C             for each report's lat/lon location in the grid, if at
C              least one of the four surrounding grid points is inside
C              the domain, then the report is considered to be inside
C              the domain and is kept; otherwise the report is
C              considered to be outside the domain and is skipped
C             (e.g.,  "F/nwprod/fix/nam_expdomain_halfdeg_imask.gbl"
C                      filters all reports outside of the 0.5 deg lat/
C                      lon mask specified in the file
C                      /nwprod/fix/nam_expdomain_halfdeg_imask.gbl)
C
C      If "yyyxxxdddddC":
C          the absence of a character "F" in position 1 and the
C          presence the character "C" in postion 12 indicates a lat/lon
C          circle is used for filtering -
C           here:
C             yyy=latitude  in center of circle in deg (N+,S-)
C             xxx=longitude in center of circle in deg (0.-360. West)
C             ddddd=radius for circle filter in km
C             (e.g.,  "045269 6500C"  filters out all reports outside of
C                      of a circle of radius 6500 km centered at 45
C                      degrees North lat and 260 degrees West lon)
C
C      If "sssnnneeewww":
C          the absence of a character "F" is postion 1 and the absence
C          of a character "C" in position 12 indicates a lat/lon
C          boundary is used for filtering - here:
C             sss=southern latitude  limit in deg (N+,S-)
C             nnn=northern latitude  limit in deg (N+,S-)
C             eee=eastern  longitude limit in deg (0.-360. West)
C             www=western  longitude limit in deg (0.-360. West)
C             (e.g.,  " 10 50 70120" filters out all reports outside of
C                      a rectangle bounded by 10-50 degrees North lat
C                      and 70-120 degrees West lon)
C
C      If "0           "  or empty:
C          no geopgraphical filtering is done
C
C     DEFINITION OF VARAIBLE "IDUP" IN THIS PROGRAM:
C      = 0 - PASSED ALL CHECKS - WRITTEN OUT
C      = 1 - REPORT SKIPPED - FAILED DUPLICATE CHECK
C      = 2 - REPORT SKIPPED - OUTSIDE TIME WINDOW
C      = 3 - REPORT SKIPPED - MISSING LATITUDE OR LONGITUDE
C      = 4 - REPORT SKIPPED - MISSING BRIGHTNESS TEMPS (HIRS-2 ONLY)
C      = 5 - REPORT SKIPPED - BAD SCAN LINE QUALITY FLAG (RARS ONLY)
C      = 6 - REPORT SKIPPED - OUTSIDE SPECIFIED GEOGRAPHICAL BOUNDARY
C      = 7 - REPORT SKIPPED - UNREASONABLE LATITUDE OR LONGITUDE
C
C     DEFINITION OF VARAIBLE "ILON" IN THIS PROGRAM:
C      = 0 - ORIGINAL LONGITUDE NOT CORRECTED (ALREADY BUFR STANDARD,
C            -180 --> +180, E+,W-)
C      = 1 - ORIGINAL LONGITUDE CORRECTED TO BUFR STANDARD (WAS
C            0 --> 360 E, NOW -180 --> +180, E+,W-)
C
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      PROGRAM BUFR_DUPSAT

      PARAMETER (MXTS=6)
      PARAMETER (NX=720,NY=361) ! Dimension of mask if using mask

      REAL(8),ALLOCATABLE :: TAB_8(:,:)
      REAL(8),ALLOCATABLE :: SLQF_8(:)
      REAL(8),ALLOCATABLE :: SAID_8(:)
      REAL(8),ALLOCATABLE :: LALO_8(:,:)
      INTEGER,ALLOCATABLE :: IWORK(:)
      INTEGER,ALLOCATABLE :: IORD(:)
      INTEGER,ALLOCATABLE :: JDUP(:)
      INTEGER,ALLOCATABLE :: JLON(:)

      COMMON /COUNT/NTAB,ISUB,ISUBO_T,ISUBO_L,IRECO_L
      COMMON /DMSGS/DUMMY_MSGS

      CHARACTER*500  FILI,FILO,CARD
      CHARACTER*80   ASTR,SSTR,TSTR
      CHARACTER*45   TEXT
      CHARACTER*10   DATE,TIME ! For date_and_time routine
                               !  (normally calls to date_and_time
                               !   are commented out)
      CHARACTER*8    SUBSET
      CHARACTER*6    LATLON_TYPE
      CHARACTER*3    DUMMY_MSGS
      CHARACTER*2    CITIMESm1

      DIMENSION      NDUP(0:7)

      REAL(8)        ADATE,BDATE,CDATE,DDATE,RDATE,UFBTAB_8,CLON_8,
     .               ALONGITUDE_8,ALATITUDE_8
      REAL(8)        BMISS,GETBMISS

      INTEGER(4)     MASK_4(NX,NY)

      LOGICAL        DUPES,SSMI,RARS,ATOVS,DEXY_READ

      DATA ASTR  /'CLATH CLONH DAYS HOUR MINU SECO'/
      DATA SSTR  /'ORBN  SCNN  DAYS HOUR MINU SECO'/
      DATA TSTR  /'CLAT  CLON  DAYS HOUR MINU SECO'/

      DATA ADATE /00000000.00_8/
      DATA BDATE /99999999.00_8/
      DATA DEXY  /0/
      DATA DDAY  /0/
      DATA DOUR  /0/
      DATA DMIN  /0/
      DATA DSEC  /0/
      DATA IREC  /1/
      DATA IFIRST_M/0/,IFIRST_U/0/

      data ireci/0/
      data isubi/0/
      data isubi_t/0/

C-----------------------------------------------------------------------
C-----------------------------------------------------------------------
      CALL W3TAGB('BUFR_DUPSAT',2021,0245,1100,'NP22')

      print *
      print * ,'---> Welcome to BUFR_DUPSAT - Version 09-02-2021'
      print *

      CALL DATELEN(10)

ccccc CALL OPENBF(0,'QUIET',2) ! Uncomment for extra print from bufrlib

C  ASSIGN DEFAULT VALUE FOR 'MISSING' TO LOCAL BMISS VARIABLE
C  ----------------------------------------------------------

      CALL SETBMISS(10E8_8)
      BMISS = GETBMISS()     ! assign default value for "missing"
      print *
      print *, 'BUFRLIB value for missing is: ',bmiss
      print *

C  SET THE COUNTERS TO INITIAL VALUES
C  ----------------------------------

      ISUB    =  0
      NDUP    =  0
      NLON    =  0
      IRECO_L =  0
      ISUBO_T =  0
      ISUBO_L =  0
      IBOX    = -1
      ISWT    =  0
      LUBFI   = 20
      LUBFC   = 30
      LUBFJ   = 50
      jnear_dup = 0
      jdiffid_dup = 0

      DEL  = .5! if filtering using mask, mask grid spacing is 0.5 deg
      ICHK = 2 ! if filtering using mask, if one of four grid points in
               !  mask surrounding report is in domain, report is
               !  considered to be in domain

C  READ I/O FILENAMES AND ANY OVERRIDE VALUES FOR THINNING PARAMETERS
C  ------------------------------------------------------------------
C     DEFAULT PARAMETERS:
C     ADATE = 00000000.00  LOWER LIMIT (YYYYMMDDHH.hh) FOR TIME WINDOW
C                          TRIMMING
C     BDATE = 99999999.00  UPPER LIMIT (YYYYMMDDHH.hh) FOR TIME WINDOW
C                          TRIMMING
C                          (I.E., NO TIME WINDOW TRIMMING IS PERFORMED)
C     DEXY  =  0.00 TOLERANCE FOR LAT/LON CHKS(NON-SSMI, NON-ATOVS RPTS)
C           =  0.01 TOLERANCE FOR LAT/LON CHKS (ATOVS REPORTS)
C           =  0.00 TOLERANCE FOR ORBIT/SCAN NUMBER CHECKS (SSMI RPTS)
C     DOUR  =  0.00 TOLERANCE FOR HOUR CHECK
C     DMIN  =  0.00 TOLERANCE FOR MINUTE CHECK
C     DSEC  =  0.00 TOLERANCE FOR SECOND CHECK
C
C     HARDWIRED PARAMETERS:
C     DDAY  = 0.0  TOLERANCE FOR DAY CHECK
C  ------------------------------------------------------------------

      READ(5,'(Q,A)',END=900,ERR=900) NBYTES_FILI,FILI(1:NBYTES_FILI)
      READ(5,'(Q,A)',END=900,ERR=900) NBYTES_FILO,FILO(1:NBYTES_FILO)

cppppp
ccc   print *, 'file fili is ',nbytes_fili,' bytes long'
ccc   print *, 'file filo is ',nbytes_filo,' bytes long'
cppppp

      DEXY_READ = .FALSE.
      READ(5,*,END=1) ADATE,BDATE
      READ(5,*,END=1) DEXY,DOUR,DMIN,DSEC
      DEXY_READ = .TRUE.
    1 CONTINUE

      CALL GETENV('LALO',CARD)
      IF(CARD.EQ.' ') GO TO 2

C  DECIDE ON GEOGRAPHICAL FILTERING METHOD-LAT/LON BOX, MASK, CIRCLE,
C   OR NONE
C  ------------------------------------------------------------------

      IF(CARD(12:12).EQ.'C')  THEN
         READ(CARD,'(2F3.0,F5.0)') RLATC,RLONC,RRADC
         IBOX = 0
         IF(RRADC.EQ.0.) IBOX = -1
      ELSE IF(CARD(1:1).EQ.'F')  THEN
         J = 0
         DO I=1,500
            J = J + 1
            IF(CARD(I:I).EQ.' ') EXIT
         ENDDO
         NBYTES_CARD = J - 1
cppp
ccc      print *, 'file card is ',nbytes_card,' bytes long'
cppp
         OPEN(LUBFC,FILE=CARD(2:NBYTES_CARD),FORM='UNFORMATTED')
         READ(LUBFC,ERR=99,END=99) MASK_4
         IBOX = 2
         GO TO 2
   99    CONTINUE
         print *
         print *, '--> BUFR_DUPSAT: ERROR READING MASK FILE'
         print *
         IBOX = -1
      ELSE
         READ(CARD,'(4F3.0)') RLATS,RLATN,RLONE,RLONW
         IBOX = 1
         IF(RLATS.EQ.0. .AND. RLATN.EQ.0.) IBOX = -1
      ENDIF

    2 CONTINUE

C  OPEN FILE TEMPORARILY TO SEE WHAT THE BUFR MESSAGE TYPE IS (SUBSET)
C  -------------------------------------------------------------------

      OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')

      CALL OPENBF(LUBFI,'IN',LUBFI)
      IF(IREADMG(LUBFI,SUBSET,IDATE).NE.0) THEN
         PRINT *, '#####BUFR_DUPSAT - NO DATA IN INPUT FILE - STOP'
         CALL W3TAGE('BUFR_DUPSAT')
         CALL ERREXIT(00)
      ENDIF
      CALL CLOSBF(LUBFI)

      SSMI=(SUBSET.EQ.'NC012001' .OR. SUBSET.EQ.'NC012002' .OR.
     .   SUBSET.EQ.'NC012103')
      RARS=(SUBSET.EQ.'NC021033' .OR. SUBSET.EQ.'NC021034' .OR.
     .      SUBSET.EQ.'NC021035' .OR. SUBSET.EQ.'NC021036')
      ATOVS=(SUBSET.EQ.'NC021023' .OR. SUBSET.EQ.'NC021024' .OR.
     .       SUBSET.EQ.'NC021025' .OR. SUBSET.EQ.'NC021027' .OR.
     .       SUBSET.EQ.'NC021028' .OR. SUBSET.EQ.'NC021123')

      IF(SSMI)  THEN
         TEXT = 'TOLERANCE FOR ORBIT/SCAN NUMBER CHECKS ..... '
      ELSE
         TEXT = 'TOLERANCE FOR LAT/LON CHECKS (IN DEGREES) .. '
         IF(ATOVS.AND..NOT.DEXY_READ) DEXY = 0.01
      ENDIF

      IF(BDATE.NE.99999999.00_8) THEN
         PRINT 200, ADATE,BDATE
      ELSE
         PRINT 201
      ENDIF
  200 FORMAT(/'REQUESTED EARLIEST DATE IS ....... ',F15.2/
     .        'REQUESTED LATEST   DATE IS ....... ',F15.2)
  201 FORMAT(/'@@@@ AS REQUESTED, NO TIME WINDOW TRIMMING IS PERFORMED'/
     .        '@@@@ ALL NON-DUPLICATES ARE RETAINED REGARDLESS OF TIME')
      PRINT 202, FILI(1:NBYTES_FILI),FILO(1:NBYTES_FILO),TEXT,DEXY,DDAY,
     . DOUR,DMIN,DSEC
  202 FORMAT(/'UNCHECKED INPUT FILE IS         '/5X,A/
     .        'DUPLICATE CHECKED OUTPUT FILE IS'/5X,A//
     .        'BUFR_DUPSAT PARAMETERS:'/
     .        3X,A45,F5.2/
     .        3X,'TOLERANCE FOR YEAR CHECK (** NOT CHECKED **) '/
     .        3X,'TOLERANCE FOR MONTH CHECK (** NOT CHECKED **) '/
     .        3X,'TOLERANCE FOR DAY CHECK (IN DAYS) .......... ',F5.2/
     .        3X,'TOLERANCE FOR HOUR CHECK (IN HOURS) ........ ',F5.2/
     .        3X,'TOLERANCE FOR MINUTE CHECK (IN MINUTES) .... ',F5.2/
     .        3X,'TOLERANCE FOR SECOND CHECK (IN SECONDS) .... ',F5.2)
      IF(IBOX.EQ.0)  THEN
         PRINT 250, RLATC,RLONC,RRADC
  250    FORMAT(3X,'GEOGRAPHICAL FILTERING IS PERFORMED HERE USING ',
     .              'LAT/LON CIRCLE:'/
     .          4X,'.. CENTRAL LATITUDE  (DEG. N+, S-) ..... ',F6.1/
     .          4X,'.. CENTRAL LONGITUDE (0-360 W) ......... ',F6.1/
     .          4X,'.. CIRCLE RADIUS (KM) .................. ',F6.1/
     .          4X,'.. ====> N O T I C E :  THIS IS NOT YET AVAILABLE',
     .              ' - GEOGRAPHICAL FILTERING NOT PERFORMED HERE'/)
         IBOX = -1 ! Not ready
      ELSE  IF(IBOX.EQ.1)  THEN
         PRINT 251, RLATN,RLATS,RLONE,RLONW
  251    FORMAT(3X,'GEOGRAPHICAL FILTERING IS PERFORMED HERE USING ',
     .              'LAT/LON BOX WITH THE FOLLOWING BOUNDARY:'/
     .          4X,'.. NORTHERN LATITUDE (DEG. N+, S-) ...... ',F6.1/
     .          4X,'.. SOUTHERN LATITUDE (DEG. N+, S-) ...... ',F6.1/
     .          4X,'.. EASTERN LONGITUDE (0-360 W) .......... ',F6.1/
     .          4X,'.. WESTERN LONGITUDE (0-360 W) .......... ',F6.1/)
         IF(RLONE.GT.RLONW) ISWT=1
      ELSE  IF(IBOX.EQ.2)  THEN
         print'(/"GEOGRAPHICAL FILTERING IS PERFORMED USING 0.5 '//
     .    'DEGREE GLOBAL LAT/LON GRID POINT MASK FILE"/A/)',
     .    CARD(2:NBYTES_CARD)
      ELSE
         PRINT 252
  252    FORMAT(3X,'GEOGRAPHICAL FILTERING NOT PERFORMED HERE'/)
      ENDIF

      OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')

      CALL MESGBC(LUBFI,MSGT,ICOMP)
      IF(ICOMP.EQ.1) THEN
         PRINT'(/"INPUT BUFR FILE MESSAGES   C O M P R E S S E D"/'//
     .    '"FIRST MESSAGE TYPE FOUND IS",I5/)', MSGT
      ELSE  IF(ICOMP.EQ.0) THEN
         PRINT'(/"INPUT BUFR FILE MESSAGES   '//
     .    'U N C O M P R E S S E D"/"FIRST MESSAGE TYPE FOUND IS",I5/)',
     .    MSGT
      ELSE IF(ICOMP.EQ.-1)  THEN
         PRINT'(//"ERROR READING INPUT BUFR FILE - MESSAGE '//
     .    'COMPRESSION UNKNOWN"/)'
      ELSE  IF(ICOMP.EQ.-3)  THEN
         PRINT'(/"INPUT BUFR FILE DOES NOT EXIST"/)'
      ELSE  IF(ICOMP.EQ.-2)  THEN
         PRINT'(/"INPUT BUFR FILE HAS NO DATA MESSAGES"/"FIRST '//
     .    'MESSAGE TYPE FOUND IS",I5/)', MSGT
      ENDIF

      CALL CLOSBF(LUBFI)

C  COUNT THE NUMBER OF SUBSETS IN THE FILE TO ALLOCATE SPACE
C  ---------------------------------------------------------

ccccc call date_and_time(date,time); print*,time,' counting'
      OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
      CALL OPENBF(0,'QUIET',1) ! will generate diagnostic print if an
                               ! embedded BUFR table is read
      CALL UFBTAB(-LUBFI,UFBTAB_8,1,1,MXTB,' ')
      CALL OPENBF(0,'QUIET',0) ! return to default wrt degree of print

ccccc call date_and_time(date,time); print*,time,' allocating',mxtb
      ALLOCATE(TAB_8(MXTS,MXTB),STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(SLQF_8(MXTB)    ,STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(SAID_8(MXTB)    ,STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(LALO_8(2,MXTB)  ,STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(IWORK(MXTB)     ,STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(IORD(MXTB)      ,STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(JDUP(MXTB)      ,STAT=I);IF(I.NE.0) GOTO 901
      ALLOCATE(JLON(MXTB)      ,STAT=I);IF(I.NE.0) GOTO 901

      TAB_8  = BMISS
      SLQF_8 = BMISS
      SAID_8 = BMISS
      LALO_8 = BMISS
      JDUP   = 0
      JLON   = 0
      ILON_CHG = 0

      OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')

C  MAKE A TABLE OUT OF THE LATS, LONS, AND TIME COORDINATES
C  CHECK TABLE A ENTRY SINCE SSM/I DATA USES A DIFFERENT CRITERIA
C  ALSO TEST FOR LOW- VS. HIGH-RESOLUTION LAT/LON (WILL LOOK THRU
C  UP TO FIRST 25 REPORTS IN CASE FIRST FEW REPORTS HAVE MISSING
C  LAT/LON)
C  --------------------------------------------------------------

ccccc call date_and_time(date,time); print*,time,' tabbing'
      LATLON_TYPE='NONE  '
      IF(SSMI) THEN ! SSMI DATA
         CALL UFBTAB(LUBFI,TAB_8,MXTS,MXTB,NTAB,SSTR)
         OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
         CALL UFBTAB(LUBFI,LALO_8,2,MXTB,NTAB,'CLAT CLON')
         LATLON_TYPE='SSMILR'
      ELSE          ! all types except SSMI
         DO ITIMES=1,MXTB ! Look thru up to 25 rpts to find a valid lat
            IF(ITIMES.EQ.26.OR.ITIMES.EQ.MXTB) THEN
               IF(ITIMES.EQ.26) THEN
                  PRINT 1858
 1858 FORMAT(/'##WARNING: THE FIRST 25 REPORTS IN INPUT FILE HAVE A ',
     $ 'MISSING LATITUDE, ALL REPORTS MAY HAVE MISSING LAT/LON'/)
C                 CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $             ' "$jlogfile" "***WARNING: THE FIRST 25 REPORTS IN'//
C    $             ' INPUT FILE HAVE A MISSING LAT, ALL REPORTS MAY '//
C    $             'HAVE MISSING LAT/LON, TYPE="'//SUBSET)
               ELSE
                  PRINT 1859
 1859 FORMAT(/'##WARNING: ALL REPORTS IN INPUT FILE HAVE MISSING LAT/',
     $ 'LON'/)
C                 CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $             ' "$jlogfile" "***WARNING: ALL REPORTS IN INPUT '//
C    $             'FILE HAVE MISSING LAT/LON, TYPE="'//SUBSET)
               ENDIF
               EXIT
            ENDIF
            CALL UFBTAB(LUBFI,TAB_8,MXTS,MXTB,NTAB,TSTR)
            LATLON_TYPE='LO-RES'
            IF(IBFMS(TAB_8(1,ITIMES)).EQ.1) THEN           ! data missing
                ! low-res lat missing for this report, try high-res lat
cpppppppppp
ccc            print *, 'For LATLON_TYPE = ',LATLON_TYPE,
ccc  $          ', TAB_8(1,',ITIMES,') missing - try next LATLON_TYPE'
cpppppppppp
            
               OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
               CALL UFBTAB(LUBFI,TAB_8,MXTS,MXTB,NTAB,ASTR)
               LATLON_TYPE='HI-RES'
               IF(IBFMS(TAB_8(1,ITIMES)).EQ.1) THEN    ! TAB_8(1,ITIMES) missing
                ! both low- & high-res lat missing for this rpt,
                !  try high-res lat for next rpt
cpppppppppp
ccc               print *, 'For LATLON_TYPE = ',LATLON_TYPE,
ccc  $             ', TAB_8(1,',ITIMES,') missing - try previous ',
ccc  $             'LATLON_TYPE again'
cpppppppppp
                 OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
                  CYCLE
               ENDIF
                ! high-res lat valid for this rpt, this is lat/lon type
               IF(ITIMES.GT.1) THEN
                  PRINT 1860, ITIMES-1
 1860 FORMAT(/'##WARNING: THE FIRST ',I2,' REPORT(S) IN INPUT FILE ',
     $ 'HAVE A MISSING LATITUDE (HIGH-RESOLUTION LAT/LON TYPE)'/)
                  WRITE(CITIMESm1,'(I2)') ITIMES-1
C                 CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $             ' "$jlogfile" "***WARNING: THE FIRST '//CITIMESm1//
C    $             ' REPORT(S) IN INPUT FILE HAVE A MISSING LATITUDE'//
C    $             ' (HIGH-RESOLUTION LAT/LON TYPE), TYPE="'//SUBSET)
               ENDIF
cpppppppppp
ccc            print *, 'For LATLON_TYPE = ',LATLON_TYPE,
ccc  $          ', TAB_8(1,',ITIMES,') valid - move on with this ',
ccc  $          'LATLON_TYPE'
cpppppppppp
               EXIT
            ELSE
                ! low-res lat valid for this rpt, this is lat/lon type
               IF(ITIMES.GT.1) THEN
                  PRINT 1861, ITIMES-1
 1861 FORMAT(/'##WARNING: THE FIRST ',I2,' REPORT(S) IN INPUT FILE ',
     $ 'HAVE A MISSING LATITUDE (LOW-RESOLUTION LAT/LON TYPE)'/)
                  WRITE(CITIMESm1,'(I2)') ITIMES-1
C                 CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $             ' "$jlogfile" "***WARNING: THE FIRST '//CITIMESm1//
C    $             ' REPORT(S) IN INPUT FILE HAVE A MISSING LATITUDE'//
C    $             ' (LOW-RESOLUTION LAT/LON TYPE), TYPE="'//SUBSET)
               ENDIF
cpppppppppp
ccc            print *, 'For LATLON_TYPE = ',LATLON_TYPE,
ccc  $          ', TAB_8(1,',ITIMES,') valid - move on with this ',
ccc  $          'LATLON_TYPE'
cpppppppppp
               EXIT
            ENDIF
         ENDDO
         IF(RARS) THEN ! RARS DATA
            OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
            CALL UFBTAB(LUBFI,SLQF_8,1,MXTB,NTAB,'SLQF')
         ENDIF
         IF(ATOVS) THEN ! ATOVS DATA
            OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
            CALL UFBTAB(LUBFI,SAID_8,1,MXTB,NTAB,'SAID')
         ENDIF
      ENDIF

C  CORRECT REPORTS WITH LON BETWEEN 180 AND 360 BY SUBTRACTING 360
C   (RE-ENCODE 0 TO 360 E LON AS -180 TO +180 LON, E+,W-, THIS IS THE
C   BUFR STANDARD)
C  ------------------------------------------------------------------

      DO N=1,NTAB
         IF(SSMI) THEN
            ALONGITUDE_8 = LALO_8(2,N)
            ALATITUDE_8  = LALO_8(1,N)
         ELSE
            ALONGITUDE_8 = TAB_8(2,N)
            ALATITUDE_8  = TAB_8(1,N)
         ENDIF
         IF(ALATITUDE_8.GE.-90.01.AND.ALATITUDE_8.LE.90.01) THEN
            IF(ALONGITUDE_8.GT.180.01.AND.ALONGITUDE_8.LE.360.00) THEN
ccccc          print *, 'Before correction: LON = ',ALONGITUDE_8
ccccc          print *, '                   LAT = ',TAB_8(1,N)
               ALONGITUDE_8  = ALONGITUDE_8  - 360.00
ccccc          print *, 'After  correction: LON = ',ALONGITUDE_8
               JLON(N) = 1
               ILON_CHG = 1
            ENDIF
         ENDIF
         IF(SSMI) THEN
            LALO_8(2,N) = ALONGITUDE_8
         ELSE
            TAB_8(2,N) = ALONGITUDE_8
         ENDIF
      ENDDO

      IF(ILON_CHG.EQ.1) THEN
         PRINT'(/"~~> At least one report has had its longitude '//
     $    'corrected from 180E --> 360E to 0W --> -180W (BUFR '//
     $    'standard)"/)'
C        CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $    ' "$jlogfile" "***WARNING: AT LEAST 1 REPORT HAS HAD ITS'//
C    $    ' LONGITUDE CORRECTED FROM 180E --> 360E TO 0W --> -180W'//
C    $    ' , TYPE="'//SUBSET)
      ENDIF

C  GET A SORTED INDEX OF THE REPORTS BY OBS TIME AND LON/LAT
C  ---------------------------------------------------------

ccccc call date_and_time(date,time); print*,time,' orders',ntab
      CALL ORDERS( 2,IWORK,TAB_8(6,1),IORD,NTAB,MXTS,8,2)
ccccc call date_and_time(date,time); print*,time,' orders'
      CALL ORDERS(12,IWORK,TAB_8(5,1),IORD,NTAB,MXTS,8,2)
ccccc call date_and_time(date,time); print*,time,' orders'
      CALL ORDERS(12,IWORK,TAB_8(4,1),IORD,NTAB,MXTS,8,2)
ccccc call date_and_time(date,time); print*,time,' orders'
      CALL ORDERS(12,IWORK,TAB_8(3,1),IORD,NTAB,MXTS,8,2)
ccccc call date_and_time(date,time); print*,time,' orders'
      CALL ORDERS(12,IWORK,TAB_8(2,1),IORD,NTAB,MXTS,8,2)
ccccc call date_and_time(date,time); print*,time,' orders'
      CALL ORDERS(12,IWORK,TAB_8(1,1),IORD,NTAB,MXTS,8,2)

      IF(.NOT.SSMI) LALO_8(1:2,:) = TAB_8(1:2,:)

C  GO THROUGH THE REPORTS IN ORDER, MARKING DUPLICATES
C  ---------------------------------------------------

ccccc call date_and_time(date,time); print*,time,' duping'

      DO K=1,NTAB

C  This loop used to end at NTAB-1 since the dup-check is always done
C   between the current report and the next one in the sort, but that
C   prevented checks on lat/lon (and for RARS reports, checks on scan
C   line calibration) for the last report in the sort - we now loop
C   through the last report in the sort in order to perform these
C   checks on that report and will account for the dup-check at NTAB-1
C   later on
C  ------------------------------------------------------------------

         IREC = IORD(K)

         IF(IBFMS(LALO_8(1,IREC)).EQ.1 .OR. 
     $      IBFMS(LALO_8(2,IREC)).EQ.1) THEN         ! data missing

C  TOSS REPORTS WITH MISSING LAT OR LON
C  ------------------------------------

            JDUP(IREC) = 3
            IF(IFIRST_M.EQ.0) THEN
               PRINT'(/"~~> Will print first 100 reports with missing'//
     $          ' latitude or longitude ..."/)'
C              CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $          ' "$jlogfile" "***WARNING: AT LEAST 1 REPORT HAS A'//
C    $          ' MISSING LAT/LON, TYPE="'//SUBSET)
            ENDIF
            IFIRST_M = IFIRST_M + 1
            IF(IFIRST_M.LE.100.OR.K.EQ.NTAB) THEN
               PRINT 857, K,(NINT(TAB_8(II,IREC)),II=3,6)
  857 FORMAT('##WARNING: REPORT NUMBER ',I10,' HAS EITHER A MISSING ',
CDONG     $ 'LAT (=',F7.2,') OR LON (=',F7.2,') - DATE (DDHHMMSS): ',4I2.2)
     $ 'LAT (=*******) OR LON (=*******) - DATE (DDHHMMSS): ',4I2.2)
               IF(K.EQ.NTAB) PRINT *,'--> above report is the last one',
     $          ' in the sort'
            ENDIF
            CYCLE
         ELSEIF((LALO_8(1,IREC).LT. -90.01.OR.LALO_8(1,IREC).GT. 90.01)
     $    .OR.
     $          (LALO_8(2,IREC).LT.-180.01.OR.LALO_8(2,IREC).GT.180.01))
     $    THEN

C  TOSS REPORTS WITH UNREASONABLE LAT OR LON
C  -----------------------------------------

            JDUP(IREC) = 7
            IF(IFIRST_U.EQ.0) THEN
               PRINT'(/"~~> Will print first 100 reports with '//
     $          'unreasonable latitude or longitude ..."/)'
C              CALL SYSTEM('[ -n "$jlogfile" ] && $DATA/postmsg'//
C    $          ' "$jlogfile" "***WARNING: AT LEAST 1 REPORT HAS A'//
C    $          ' UNREASONABLE LAT/LON, TYPE="'//SUBSET)
            ENDIF
            IFIRST_U = IFIRST_U + 1
            IF(IFIRST_U.LE.100.OR.K.EQ.NTAB) THEN
               PRINT 858, K,TAB_8(1,IREC),TAB_8(2,IREC),
     $          (NINT(TAB_8(II,IREC)),II=3,6)
  858 FORMAT('##WARNING: REPORT NUMBER ',I10,' HAS EITHER AN ',
     $ 'UNREASONABLE LAT (=',F7.2,') OR LON (=',F7.2,') - DATE',
     $ ' (DDHHMMSS): ',4I2.2)
               IF(K.EQ.NTAB) PRINT *,'--> above report is the last one',
     $          ' in the sort'
            ENDIF
            CYCLE
         ELSE  IF(RARS) THEN

C  SKIP "RARS" REPORTS IF SCAN LINE WAS CALIBRATED USING FEWER THAN THE
C   PREFERRED NUMBER OF SCAN LINES BECAUSE OF PROXIMITY TO START OR END
C   OF DATA OR TO A DATA GAP (BIT 6 SET IN SCAN LINE QUALITY FLAGS)
C   (Note: Examination of the input tanks show that these are often
C          duplicates in time and location with "good" scans - tossing
C          them before the dup-check ensures that the good scans will
C          be used)
C   (Note: For some reason, never see duplcates with Bit 6 + some other
C          bit turned on, so we'll let these through even though these
C          scans may also be "bad" - let analysis test quality flags)
C  --------------------------------------------------------------------

            IF(SLQF_8(IREC).EQ.262144) THEN
               JDUP(IREC) = 5
               IF(K.EQ.NTAB) PRINT *,'--> last report in the sort ',
     $          'failed the RARS scan line calibration check'
               CYCLE
            ENDIF
         ENDIF

C=======================================================================

C  COME HERE FOR GEOGRAPHICAL FILTERING
C  ------------------------------------

         IF(IBOX.GE.0)  THEN

            ALAT = LALO_8(1,IREC)

C  Convert the longitude to west longitude
C  ---------------------------------------

            IF(LALO_8(2,IREC) .LT. 0.) THEN
                ALONW = -LALO_8(2,IREC)
            ELSE
                ALONW = 360. - LALO_8(2,IREC)
            ENDIF

C  Convert the longitude to east longitude
C  ---------------------------------------

            ALONE = 360. - ALONW

            IF(IBOX.EQ.1) THEN

C  Filter reports using the latitude/longitude box
C  -----------------------------------------------

               IF(ALAT.GT.RLATN .OR. ALAT.LT.RLATS) THEN
                  JDUP(IREC) = 6
                  IF(K.EQ.NTAB) PRINT *,'--> last report in the sort ',
     $             'is outside the requested lat/lon box'
                  CYCLE
               ENDIF
               IF(ISWT.EQ.0) THEN
                  IF(ALONW.GT.RLONW .OR. ALONW.LT.RLONE) THEN
                     JDUP(IREC) = 6
                     IF(K.EQ.NTAB) PRINT *,'--> last report in the ',
     $                'sort is outside the requested lat/lon box'
                     CYCLE
                  ENDIF
               ELSE
                  IF(ALONW.GT.RLONW .AND. ALONW.LT.RLONE) THEN
                     JDUP(IREC) = 6
                     IF(K.EQ.NTAB) PRINT *,'--> last report in the ',
     $                'sort is outside the requested lat/lon box'
                     CYCLE
                  ENDIF
               ENDIF
            ELSE IF(IBOX.EQ.0) THEN

C  Filter reports using the lat/lon circle (not yet ready)
C  -------------------------------------------------------

               CALL CHDIST(RLONC,RLATC,ALONW,ALAT,RDIST)
               IF(RDIST.GT.RRADC) THEN
                  JDUP(IREC) = 6
                  IF(K.EQ.NTAB) PRINT *,'--> last report in the sort ',
     $             'is outside the requested lat/lon circle'
                  CYCLE
               ENDIF
            ELSE  IF(IBOX.EQ.2) THEN

C  Filter reports using 0.5 degree global lat/lon grid point mask
C  --------------------------------------------------------------

               CALL GEOCHK(ALAT,ALONE,ICHK,MASK_4,NX,NY,DEL,IGEO)
               IF(IGEO.EQ.0) THEN
                  JDUP(IREC) = 6
                  IF(K.EQ.NTAB) PRINT *,'--> last report in the sort ',
     $             'is outside the requested lat/lon grid point mask'
                  CYCLE
               ENDIF
            ENDIF
         ENDIF

C=======================================================================

C  If the current report is the last report in the sort, exit the loop
C   since this report has already been considered in the dup-check
C  -------------------------------------------------------------------

         IF(K.EQ.NTAB) EXIT

         JREC = IORD(K+1)

         IF(
CDONG     .    NINT(ABS(TAB_8(1,IREC)-TAB_8(1,JREC))*100000.).LE.
CDONG     .                                                NINT(DEXY*100000.)
     .    ABS(TAB_8(1,IREC)-TAB_8(1,JREC)).LE.DEXY .AND.
CDONG     .    NINT(ABS(TAB_8(2,IREC)-TAB_8(2,JREC))*100000.).LE.
CDONG     .                                                NINT(DEXY*100000.)
     .    ABS(TAB_8(2,IREC)-TAB_8(2,JREC)).LE.DEXY .AND.
     .    NINT(ABS(TAB_8(3,IREC)-TAB_8(3,JREC))*100.).LE.NINT(DDAY*100.)
     .    .AND.
     .    NINT(ABS(TAB_8(4,IREC)-TAB_8(4,JREC))*100.).LE.NINT(DOUR*100.)
     .    .AND.
     .    NINT(ABS(TAB_8(5,IREC)-TAB_8(5,JREC))*100.).LE.NINT(DMIN*100.)
     .    .AND.
     .    NINT(ABS(TAB_8(6,IREC)-TAB_8(6,JREC))*100000.).LE.
     .                                               NINT(DSEC*100000.))
     .    JDUP(IREC) = 1
         inear_dup = 0
         idiffid_dup = 0
         if(jdup(irec).eq.1) then
            if(abs(tab_8(1,irec)-tab_8(1,jrec))*100000.gt.0 .or.
     .         abs(tab_8(2,irec)-tab_8(2,jrec))*100000.gt.0) then
               jnear_dup = jnear_dup + 1
               inear_dup = 1
            endif
            if(said_8(irec).ne.said_8(jrec)) then
               jdiffid_dup = jdiffid_dup + 1
               idiffid_dup = 1
            endif
C  .. uncomment 2 lines below if you want to list ONLY duplicates with
C      different satellite ids
            if(idiffid_dup.eq.1) then
               print *,'Duplicate-pair with different satellite id''s;'
C  .. otherwise, uncomment 5 lines below if you want to list ONLY
C      duplicates with different satellite ids or ALL near-duplicates
ccccc       if(inear_dup.eq.1 .or. idiffid_dup.eq.1) then
ccccc          if(inear_dup.eq.1) print *,'Near-duplicate-pair treated',
ccccc.          ' as duplicate;'
ccccc          if(idiffid_dup.eq.1) print *,'Duplicate-pair with ',
ccccc.          'different satellite id''s;'
      print *,'SAID(IREC),SAID(JREC): ',SAID_8(IREC),SAID_8(JREC)
      print *,'TAB(1,IREC),TAB(1,JREC): ',TAB_8(1,IREC),TAB_8(1,JREC)
      print *,'TAB(2,IREC),TAB(2,JREC): ',TAB_8(2,IREC),TAB_8(2,JREC)
      print *,'TAB(3,IREC),TAB(3,JREC): ',TAB_8(3,IREC),TAB_8(3,JREC)
      print *,'TAB(4,IREC),TAB(4,JREC): ',TAB_8(4,IREC),TAB_8(4,JREC)
      print *,'TAB(5,IREC),TAB(5,JREC): ',TAB_8(5,IREC),TAB_8(5,JREC)
      print *,'TAB(6,IREC),TAB(6,JREC): ',TAB_8(6,IREC),TAB_8(6,JREC)
      print *,'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'
ccccc    call errexit (55) ! uncomment to stop after first listing
C  .. comment out below line if you want to list ALL duplicates
            endif
         endif
      ENDDO

C  TRIM THE EXCESS DATA FROM THE EXACT TIME WINDOW (IF REQESTED)
C  -------------------------------------------------------------

ccccc call date_and_time(date,time); print*,time,' window'
      IF(BDATE.NE.99999999.00_8) THEN
         CDATE = MOD(ADATE,10000._8)
         DDATE = MOD(BDATE,10000._8)
         DO K=1,NTAB
            IF(IBFMS(TAB_8(6,K)).EQ.1) TAB_8(6,K)=0 ! Set missing sec to 0
            RDATE=
     .        TAB_8(3,K)*1E2+TAB_8(4,K)+(TAB_8(5,K)*60+TAB_8(6,K))/3600.
            IF(CDATE.LE.DDATE) THEN
               IF(RDATE.LT.CDATE .OR.  RDATE.GT.DDATE) JDUP(K) = 2
            ELSE
               IF(RDATE.LT.CDATE .AND. RDATE.GT.DDATE) JDUP(K) = 2
            ENDIF
         ENDDO
      ENDIF

C  WRITE A DUP-CHECKED, TIME WINDOW-TRIMMED, AND MAYBE ALSO LONGITUDE
C   CORRECTED FILE
C  ------------------------------------------------------------------

ccccc call date_and_time(date,time); print*,time,' writing'
      OPEN(LUBFI,FILE=FILI(1:NBYTES_FILI),FORM='UNFORMATTED')
      OPEN(LUBFJ,FILE=FILO(1:NBYTES_FILO),FORM='UNFORMATTED')
      CALL OPENBF(LUBFI,'IN ',LUBFI)
      CALL OPENBF(LUBFJ,'OUT',LUBFI)
      CALL MAXOUT(25000)

      CALL GETENV('DUMMY_MSGS',DUMMY_MSGS)

C  If input file doesn't contain dummy center and dump time messages 1
C   and 2 (after table messages), before doing anything call CLOSMG
C   with a negative unit number to signal routine that it should not
C   write out ANY messages with zero subsets in them - this holds for
C   all subsequent calls to CLOSMG in this routine, even those done
C   through other bufrlib routines (and even for those calls where the
C   sign of the unit number is positive)
C  --------------------------------------------------------------------

      IF(DUMMY_MSGS.NE.'YES') CALL CLOSMG(-LUBFJ)

C  SPECIAL BRANCHES FOR SOME DATA TYPES
C  ------------------------------------

      IF(SUBSET(1:5).EQ.'NC005'.AND.SUBSET(6:7).NE.'03')  THEN
         CALL SATWND_ID(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
     $                  LATLON_TYPE,ICOMP)!Satwnds (except GOES-16 & up)
      ELSEIF(SUBSET.EQ.'NC003001'.OR.SUBSET.EQ.'NC003002'.OR.
     $       SUBSET.EQ.'NC003003')  THEN
         CALL GOESND_ID(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
     $                  LATLON_TYPE,ICOMP) ! GOES soundings
      ELSEIF(SUBSET.EQ.'NC021021')  THEN
         CALL HIRS2(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,LATLON_TYPE,
     $              ICOMP) ! ATOVS HIRS2 1B
      ELSE
                                     ! Everything else
         DO WHILE(IREADMG(LUBFI,SUBSET,IDATE).EQ.0)

cppppp
cdak        call ufbcnt(lubfi,ireci,idummy)
cdak        isubi = nmsub(lubfi)
cdak        isubi_t = isubi_t + isubi
cdak        print *, '===> READ IN BUFR DATA MSG # ',ireci,' -- TABLE ',
cdak $       'A ENTRY "',SUBSET,'", DATE ',idate,' - ',isubi,' RPTS IN',
cdak $       ' MSG; TOTAL # RPTS SO FAR ',isubi_t
cppppp

            NSUBS = NMSUB(LUBFI)

C  If no subsets in msg & dummy msgs not expected, loop to nxt input msg
C  ---------------------------------------------------------------------

            IF(NSUBS.LE.0.AND.DUMMY_MSGS.NE.'YES')  CYCLE

            IF(NSUBS.EQ.0)  THEN
cppppp
cdak           if(ireci.eq.1)  then
cdak              print *, '   -- this is dummy message 1, the center ',
cdak $             'time - copy to output file'
cdak           else if(ireci.eq.2)  then
cdak              print *, '   -- this is dummy message 2, the dump ',
cdak $             'time - copy to output file'
cdak           else
cdak              print *, '   -- this message has no reports in it ',
cdak $             'for some unexplained reason!! (go ahead and copy ',
cdak $             'to output file'
cdak           endif
cppppp
               CALL CLOSMG(LUBFJ)
               CALL COPYMG(LUBFI,LUBFJ)
cppppp
cdak           call ufbcnt(lubfj,ireco,isubo)
cdak           if(ireco.gt.ireco_l)  then
cdak              isubo_t = isubo_t + isubo_l
cdak              print *, ' --- OPEN EMPTY BUFR MSG WITH DATE',idate,
cdak $             ': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,' RPTS',
cdak $             ' (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak           endif
cdak           isubo_l = isubo
cdak           ireco_l = ireco
cppppp
               CYCLE
            ENDIF

            IF(ILON_CHG.EQ.0) THEN

C   ... Come here if no reports had their longitude corrected, will do
C        dup-check and time-window trimming only (if necessary)
C       --------------------------------------------------------------

               DUPES = .FALSE.
               IF(NSUBS.GT.0) THEN
                  DO N=1,NSUBS
                     IDUP = JDUP(ISUB+N)       !check the dupe code
                     NDUP(IDUP) = NDUP(IDUP)+1 !count dupe types
                     IF(IDUP.GT.0) DUPES=.TRUE.!remember if dupes in msg
                  ENDDO
               ENDIF
               IF(DUPES) THEN
                  CALL OPENMB(LUBFJ,SUBSET,IDATE)
                  IF(NSUBS.GT.0) THEN
                     DO N=1,NSUBS
                        IF(JDUP(ISUB+N).EQ.0) THEN
                           CALL COPYSB(LUBFI,LUBFJ,IRET)
                        ELSE
                           CALL COPYSB(LUBFI,00000,IRET)
                        ENDIF
                     ENDDO
                  ENDIF
               ELSE

C  In the event that the input file contains dummy center and dump time
C    messages 1 and 2 (after table messages), call CLOSMG with a
C    positive unit number to signal routine that it should write out
C    these messages even though they have zero subsets in them
C  If the input file does not contain dummy messages, a positive unit
C    number here is immaterial because CLOSMG was already called with
C    a negative unit number immediately after the output file was
C    opened (and this holds for all subsequent calls to CLOSMG
C    regardless of the sign of the unit number)
C  -------------------------------------------------------------------

                  CALL CLOSMG(LUBFJ)
                  CALL COPYMG(LUBFI,LUBFJ)
               ENDIF
               ISUB = ISUB+NSUBS
            ELSE

C   ... Come here if at least one report had its longitude corrected,
C        will do dup-check and time-window trimming and will encode
C        corrected longitude into output file (if necessary)
C       -------------------------------------------------------------

               DO WHILE(IREADSB(LUBFI).EQ.0)
                  ISUB = ISUB+1
                  IDUP = JDUP(ISUB)          ! check the dupe code
                  NDUP(IDUP) = NDUP(IDUP)+1  ! count dupe types
                  ILON = JLON(ISUB)          ! check the lon corr. code
                  IF(IDUP.NE.0)  CYCLE  ! this is a duplicate, skip it
                  CALL OPENMB(LUBFJ,SUBSET,IDATE)
                  CALL UFBCPY(LUBFI,LUBFJ)
                  IF(ILON.NE.0)  THEN   ! this longitude was corrected
                                        ! encode the corrected value
                     CLON_8 = TAB_8(2,ISUB)
                     IF(LATLON_TYPE.EQ.'HI-RES') THEN
                        CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLONH')
                     ELSE IF(LATLON_TYPE.EQ.'LO-RES') THEN
                        CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLON')
                     ELSE IF(LATLON_TYPE.EQ.'SSMILR') THEN
                        CLON_8 = LALO_8(2,ISUB)
                        CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLON')
                     ENDIF
                     NLON = NLON +1             ! count lon corr. types
                  ENDIF
                  IF(ICOMP.EQ.1) THEN
C       ... write out compressed BUFR messages if input msgs are such
                     CALL WRITCP(LUBFJ)
                  ELSE
C       ... otherwise write out uncompressed BUFR messages
                     CALL WRITSB(LUBFJ)
                  ENDIF
cppppp
cdak              call ufbcnt(lubfj,ireco,isubo)
cdak              if(ireco.gt.ireco_l)  then
cdak                 isubo_t = isubo_t + isubo_l
cdak        print *, ' --- THIS REPORT OPENS NEW BUFR MSG WITH DATE ',
cdak $       idate,': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,
cdak $       ' RPTS (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak              endif
cdak              isubo_l = isubo
cdak              ireco_l = ireco
cppppp
               ENDDO ! end of readsb loop
            ENDIF
         ENDDO
      ENDIF
cppppp
cdak  call ufbcnt(lubfj,ireco,isubo)
cdak  isubo_t = isubo_t + isubo_l
cdak  print *, ' --- LAST MSG WRITTEN WAS NO.',ireco-1,' WITH',isubo_l,
cdak $ ' RPTS (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak  isubo_t = isubo_t + isubo
cdak  print *, ' --- WROTE FINAL BUFR MSG NO.',ireco,' WITH',isubo,
cdak $ ' RPTS (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cppppp

ccccc call date_and_time(date,time); print*,time,' finishing'
      CALL CLOSBF(LUBFI)
      CALL CLOSBF(LUBFJ)
      OPEN(LUBFJ,FILE=FILO(1:NBYTES_FILO),FORM='UNFORMATTED')
      CALL MESGBC(LUBFJ,MSGT,ICOMP)
      IF(ICOMP.EQ.1) THEN
         PRINT'(/"OUTPUT BUFR FILE MESSAGES   C O M P R E S S E D"/'//
     .    '"FIRST MESSAGE TYPE FOUND IS",I5/)', MSGT
      ELSE  IF(ICOMP.EQ.0) THEN
         PRINT'(/"OUTPUT BUFR FILE MESSAGES   '//
     .    'U N C O M P R E S S E D"/"FIRST MESSAGE TYPE FOUND IS",I5/)',
     .    MSGT
      ELSE IF(ICOMP.EQ.-1)  THEN
         PRINT'(//"ERROR READING OUTPUT BUFR FILE - MESSAGE '//
     .        'COMPRESSION UNKNOWN"/)'
      ELSE  IF(ICOMP.EQ.-3)  THEN
         PRINT'(/"OUTPUT BUFR FILE DOES NOT EXIST"/)'
      ELSE  IF(ICOMP.EQ.-2)  THEN
         PRINT'(/"OUTPUT BUFR FILE HAS NO DATA MESSAGES"/"FIRST '//
     .    'MESSAGE TYPE FOUND IS",I5/)', MSGT
      ENDIF
      CLOSE(LUBFJ)
      CLOSE(LUBFC)

C  GENERATE REPORT
C  ---------------

      PRINT 300, ISUB,NTAB,NDUP(0),NDUP(3),NDUP(7),NDUP(1)
  300 FORMAT(/'BUFR_DUPSAT READ IN A TOTAL OF',I12,' REPORTS'/
     .        'BUFR_DUPSAT CHECKED A TOTAL OF',I12,' REPORTS'//
     .        'NUMBER OF REPORTS WRITTEN OUT .....................',I12/
     .        'NUMBER OF REPORTS SKIPPED DUE TO:'/
     .        '   MISSING LATITUDE OR LONGITUDE ..................',I12/
     .        '   UNREASONABLE LATITUDE OR LONGITUDE .............',I12/
     .        '   FAILING DUPLICATE CHECK ........................',I12)
      if(jnear_dup.gt.0) PRINT 306, jnear_dup
  306 FORMAT( '   ... number of above w/i lat/lon tolerance ..',I8)
      if(jdiffid_dup.gt.0) PRINT 307, jdiffid_dup
  307 FORMAT( '   ... number of above w/ different sat. ids ..',I8)
      PRINT 305, NDUP(2)
  305 FORMAT( '   BEING OUTSIDE TIME WINDOW FOR TRIMMING .........',I12)
      IF(SUBSET.EQ.'NC021021') PRINT 301, NDUP(4)
  301 FORMAT( '   FAILING B. TEMPERATURE GROSS CHECK (HIRS2) .....',I12)
      IF(RARS) PRINT 302, NDUP(5)
  302 FORMAT( '   BAD SCAN LINE QUALITY FLAG (BIT 6 SET) (RARS) ..',I12)
      IF(IBOX.GE.0) PRINT 303, NDUP(6)
  303 FORMAT( '   GEOGRAPHIC FILTERING ...........................',I12)
      PRINT 304, NLON
  304 FORMAT( 'NUMBER OF RPTS WITH LONGITUDE CORRECTED (BUFR STD).',I12)

C  END OF PROGRAM
C  --------------

      CALL W3TAGE('BUFR_DUPSAT')
      STOP

C  ERROR EXITS
C  -----------

900   CONTINUE

      PRINT *, '#####BUFR_DUPSAT - EOF/ERR READING STDIN'
      CALL W3TAGE('BUFR_DUPSAT')
      CALL ERREXIT(99)

901   CONTINUE

      PRINT *, '#####BUFR_DUPSAT - UNABLE TO ALLOCATE ARRAYS'
      CALL W3TAGE('BUFR_DUPSAT')
      CALL ERREXIT(99)

      END

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    SATWND_ID
C   PRGMMR: KEYSER           ORG: NP22        DATE: 2015-01-28
C
C ABSTRACT: PERFORMS DUPLICATE CHECKING AND (OPTIONAL) TRIMMING TO
C   EXACT TIME WINDOW (DAY DOWN TO SECOND), AND THEN UPDATES THE REPORT
C   ID AND LONGITUDE {ALREADY CORRECTED TO BUFR STANDARD
C   (-180 --> +180, E+,W- INSTEAD OF 0 --> 360 E) IF NECESSARY} IN
C   OUTPUT FILE FOR ALL SATELLITE-DERIVED WIND TYPES EXCEPT FOR GOES-16
C   AND UP.
C
C PROGRAM HISTORY LOG:
C 2000-12-05  KEYSER -- ORIGINAL AUTHOR
C 2001-04-06  D. A. KEYSER -- MODIFIED TO HANDLE NEW BUFR EUMETSAT
C     WINDS IN SUBSETS "NC005064", "NC005065" AND "NC005066"
C 2001-07-20  D. A. KEYSER -- INCREASED MXTB FROM 800000 TO 2400000
C     TO HANDLE LARGE VOLUME GOES SFOV CLOUD-TOP PROCESSING
C 2001-10-01  D. A. KEYSER -- INCREASED MXTB FROM 2400000 TO 3600000
C     TO HANDLE LARGE VOLUME GOES SFOV CLOUD-TOP PROCESSING
C 2002-11-18  D. A. KEYSER -- MODIFICATIONS TO PREVENT ARRAY OVERFLOW
C     WHEN THERE ARE > MXTB REPORTS
C 2003-05-23  D. A. KEYSER -- GOES-9 (SAT. ID 253) WINDS WITH BUFR
C     MESSAGE SUBTYPE 41-43 ALWAYS GET "P" IN 1ST CHAR. OF STN. ID AND
C     "D" (PROCUCER = JMA) IN 2ND CHAR. OF STN. ID. (JMA BEGAN
C     PRODUCING WINDS FROM GOES-9 IN PLACE OF FAILING GMS-5 ON
C     23 MAY 2003), WHEN NESDIS PRODUCES WINDS FROM GOES-9 THE FIRST
C     CHAR. IN THE STN. ID IS "C" (AS BEFORE)
C 2004-02-02  D. KEYSER    ADDED LOGIC TO HANDLE FUTURE NASA/MODIS
C     (AQUA/TERRA) POES WINDS AND GTS NESDIS GOES WINDS
C 2005-03-14  D. KEYSER   CHANGES IN RESPONSE TO NESDIS' CORRECTION OF
C     AN ERROR (EFF. 3/10/2005) WHICH HAD STORED SIDP (SATELLITE
C     INSTRUMENT USED IN DATA PROCESSING) AS A CODE TABLE VALUE RATHER
C     THAN CORRECTLY AS A FLAG TABLE VALUE (THE CHANGE BY NESDIS
C     RESULTED IN INSTRUMENT TYPE BEING STORED AS MISSING AND THE
C     REPORT ID NOT BEING INDEXED) (WILL STILL WORK OK FOR HISTORICAL
C     RUNS PRIOR TO NESDIS FIX)
C 2005-07-20  D. KEYSER   CHANGES IN RESPONSE TO JMA'S SWITCH FROM
C     GOES-9 (SATELLITE ID 253) TO NEW MTSAT-1R (SATELLITE ID 171) ON
C     7/15/2005, FIRST CHARACTER OF RPID IS "Q" FOR MTSAT-1R
C 2005-10-19  J. WOOLLEN  MODIFIED STREAM TO INCREASE EFFICIENCY
C 2007-11-02  D. KEYSER   ENCODES ANY LONGITUDES THAT HAVE BEEN
C     CORRECTED TO BUFR STANDARD IN MAIN PROGRAM (I.E., 0 --> 360 E
C     CHANGED TO -180 --> +180, E+,W-) 
C 2010-09-30  D. KEYSER   CHANGES IN RESPONSE TO JMA'S SWITCH FROM
C     MTSAT-1R (SATELLITE ID 171) TO NEW MTSAT-2 (SATELLITE ID 172) ON
C     8/11/2010, FIRST CHARACTER OF RPID IS "R" FOR MTSAT-2; UPDATED TO
C     ACCOUNT FOR FUTURE SATELLITE IDS (E.G., METOP AND NOAA FOR
C     FUTURE AVHRR WINDS, FUTURE JMA AND EUMETSAT SATELLITES)
C 2011-05-09  D. KEYSER   CORRECTED BUG WHICH LED TO CHARACTERS 3-7 OF
C     GENERATED RPID BEING "?????" (RATHER THAN AN INCREMENTED COUNT)
C     FOR MODIS (AQUA/TERRA) IR AND WV WIND REPORTS (OCCURRED AFTER
C     NESDIS MADE CHANGE IN SPRING 2010 TO CORRECTLY DESIGNATE THESE AS
C     POES IMAGER WINDS RATHER THAN AS GEOSTATIONARY IMAGER WINDS);
C     MORE CHANGES MADE TO PROPERLY HANDLE FUTURE AVHRR POES WINDS;
C     THE OUTPUT FILE WILL NOW BE IN THE SAME BUFR COMPRESSION STATE AS
C     THE INPUT FILE (RATHER THAN ALWAYS UNCOMPRESSED) (NOTE: CURRENTLY
C     THIS TYPE ALWAYS COMES IN AS UNCOMPRESSED SO THIS WOULD ONLY
C     AFFECT FUTURE FILES FOR THIS TYPE WHICH MIGHT COME IN AS
C     COMPRESSED BUFR)
C 2013-01-14  J. WHITING  REPLACED TESTS VS BMISS W/ IBFMS FUNCTION;
C     CHANGED IBFMS ARG VARIABLES TO 8BYTE REALS (IE, SWPR TO SWPR_8,
C     ETC); REMOVED BMISS DATA STATEMENT.
C 2015-01-28  D. KEYSER
C      - IR (long-wave) NPP VIIRS POES winds now handled. These have
C        message type NC005090 and BUFR satellite ID 224. Get
C        previously unused character "J" in 1st character of generated
C        RPID and "9" (meaning NASA is producer) in 2nd character of
C        RPID.
C      - IR (short-wave) GOES winds now handled. These have message
C        type NC0050019.  Get previously unused character "S" in 8th
C        character of generated RPID. New instrument/product type (ITP)
C        19 is defined for IR short-wave imager automated winds. This
C        allows a unique sequential serial index (counter) to be used
C        to generate characters 3-7 of RPID for each individual
C        satellite.
C 2019-04-16  S. MELCHIOR: IR (long-wave) NOAA-20 VIIRS POES winds
C        now handled. These have message type NC005090 and BUFR
C        satellite ID 225. Get previously unused character "S" in 1st
C        character of generated RPID and "9" (meaning NASA is
C        producer) in 2nd character of RPID.
C
C USAGE:    CALL SATWND_ID(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
C                          LATLON_TYPE,ICOMP)
C   INPUT ARGUMENT LIST:
C     LUBFI    - INPUT  BUFR FILE UNIT NUMBER
C     LUBFJ    - OUTPUT BUFR FILE UNIT NUMBER
C     JDUP     - ARRAY CONTAINING DUPLICATE TYPE FOR ALL SUBSETS IN
C                INPUT BUFR FILE (SORTED) (0 - NOT A DUP, 1 - DUP,
C                2 - OUTSIDE TIME WINDOW, 3 - MISSING LAT OR LON,
C                4-7 - RESERVED)
C     JLON     - ARRAY CONTAINING LONGITUDE CORRECTION TYPE FOR ALL
C                SUBSETS IN INPUT BUFR FILE (SORTED) (0 - NO
C                CORRECTION, 1 - CORRECTION TO BUFR STANDARD)
C     LALO_8   - REAL(8) ARRAY CONTAINING LATITUDES AND LONGITUDES
C                (LATTER POSSIBLY CORRECTED) FOR ALL SUBSETS IN INPUT
C                BUFR FILE (SORTED)
C     LATLON_TYPE - CHARACTER*6 STRING INDICATING LAT/LON RESOLUTION
C                   (EITHER 'HI-RES', 'LO-RES', 'SSMILR' or 'NONE  ')
C     ICOMP    - INDICATOR AS TO WHETHER OR NOT INPUT BUFR MESSAGES ARE
C                COMPRESSED (0 - UNCOMPRESSED, 1 - COMPRESSED, ANYTHING
C                ELSE - UNKNOWN)
C
C   OUTPUT ARGUMENT LIST:
C     NDUP     - ARRAY HOLDING COUNTS ACCORDING TO DUPLICATE TYPE
C     NLON     - COUNTER OF REPORTS FOR WHICH A LONGITUDE CORRECTION
C                WAS PERFORMED
C
C   INPUT FILES:
C     UNIT "LUBFI" - INPUT  BUFR FILE
C
C   OUTPUT FILES:
C     UNIT "LUBFJ" - OUTPUT BUFR FILE
C
C REMARKS: THE DUPLICATE CHECKING AND LONGITUDE CORRECTION ENCODING
C     LOGIC HERE IS NO DIFFERENT FROM THAT FOR ALL OTHER DATA TYPES
C     (SEE MAIN PROGRAM). THIS SUBROUTINE IS UNIQUE TO SATELLITE WIND
C     REPORTS BECAUSE IT GENERATES A NEW FORM OF THE REPORT ID WHICH IS
C     UNIQUE FOR ALL REPORTS IN THE OUTPUT FILE.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      SUBROUTINE SATWND_ID(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
     $                     LATLON_TYPE,ICOMP)

      CHARACTER*1  CPROD(0:4),CSAT(784),CPRDF(0:2),CPRDFN(90)
      CHARACTER*8  SUBSET,SID
      CHARACTER*6  LATLON_TYPE
      CHARACTER*3  DUMMY_MSGS

      REAL(8)  UFBINT_8,RPID_8,CLON_8,LALO_8(2,NTAB)
      REAL(8)  SWPR_8,SWTP_8,CMCM_8     ! IBFMS arguments

      INTEGER  JDUP(NTAB),NDUP(0:7),IPRDF(0:2),KOUNT(784,19,2),
     $ ISWCM(5,9:13,2),JLON(NTAB)

      COMMON /COUNT/NTAB,ISUB,ISUBO_T,ISUBO_L,IRECO_L
      COMMON /DMSGS/DUMMY_MSGS

      EQUIVALENCE  (RPID_8,SID)

      data ireci/0/
      data isubi/0/
      data isubi_t/0/

      DATA KOUNT/29792*0/

C---------------------------------------------------------------------

      DATA CSAT /  ! character 1 in report id for winds (character
                   ! meaning defined further below)
                   ! (Note:  no unique characters remain - must 
                   !         recycle old ones)

C                 **  METOP **
C ---- spare(1-2) 3   4   5
     $     2*'?','H','E','I'

C ---- spare(6-49)
     $,   44* '?'

C                 **  Meteosat  **
C ---- 50  51  52  53  54  55  56  57  58  59 sp(60-69) 70 sp(71-98) 99
     $,'Z','W','X','Y','Z','W','X','Y','Z','W',10* '?', 'Z',28* '?', 'X'

C ---- spare(100-149)
     $,   50* '?'

C                    **  GMS/MTSAT/HIMAWARI **
C ---- 150 151 152 sp(153-170) 171 172 173 174 175 176 sp(177-198) 199
     $,'R','O','P', 18* '?',   'Q','R','O','P','Q','R', 22* '?',   'Q'

C                    ** NOAA **
C ---- spare(200-205) 206 207 208 209 spare(210-222) 223
     $,    6* '?',    'F','L','M','N',   13* '?',    'G'

C                    ** NPP **
C ---- 224 225
     $,'J','S'

C ---- spare(226-249)
     $,   24* '?'

C                    **  GOES **
C ---- 250 251 252 253 254 255 256 257 258 259
     $,'D','A','B','C','D','A','B','C','D','A'


C ---- spare(260-439)
     $,  180* '?'

C                   **  Kalpana **
C ---- 440
     $,'K'

C ---- spare(441-469)
     $,   29* '?'

C                   **  Insat **
C ---- 470 spare(471-498) 499
     $,'V',   28* '?',    'V'

C ---- spare(500-782)
     $,  283* '?'

C                   **  Terra **
C ---- 783
     $,'T'

C                    ** Aqua **
C ---- 784
     $,'U' /

C---------------------------------------------------------------------

      DATA CPROD / ! character 2 in report id for winds from foreign
                   ! producers (i.e., EUMETSAT, JMA and INSAT)
                   ! (character meaning defined further below)

C   Satellite id divided by 100 (i.e., X in Xuu, where Xuu is
C   satellite id)
C X=    0   1   2   3   4
C      --  --  --  --  --
     $ 'C','D','?','?','E' /

C---------------------------------------------------------------------

      DATA CPRDF / ! character 8 in report id for winds from foreign
                   ! producers (i.e., EUMETSAT, JMA and INSAT)
                   ! (character meaning defined further below)

C   BUFR report message sub-type (sss in NC005ssX), where ss=02,04,06
C X=     3    1    2
C          - or -
C X=     6    4    5
C       --   --   --
     $ 'V', 'C', 'B' /

C---------------------------------------------------------------------

      DATA CPRDFN / ! character 8 in report id for winds from NESDIS or
                    ! NASA (character meaning defined further below)

C     BUFR report message sub-type (sss in NC005sss)
C sss=  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16
     $ 'C','C','V','C','I','W','?','Z','P','I','W','Z','P','T','I','W',

C sss=  17  18  19  20-49  50  51  52-69  70  71  72-79  80  81-89  90
     $ 'V','T','S',30*'?','C','V',18*'?','I','W', 8*'?','I', 9*'?','I' /

C---------------------------------------------------------------------

      DATA IPRDF /  ! defines the instrument/product type (ITP) for
                    ! winds from foreign producers (i.e., EUMETSAT, JMA
                    ! and INSAT), where:

C          1       IR (LW) automated winds (low density)
C          4       Water vapor automated (low density)
C          6       Visible automated (low density)

C   BUFR report message sub-type (sss in NC005ssX), where ss=02,04,06
C X=    3    1    2
C         - or -
C X=    6    4    5
C      --   --   --
     $  4 ,  1 ,  6 /

C---------------------------------------------------------------------

      DATA ISWCM /  ! defines the instrument/product type (ITP) for
                    ! winds from NESDIS or NASA, where:

C          1       IR (LW) automated winds (low density)
C          3       Picture triplet (low density)
C          4       Water vapor automated (low density)
C          6       Visible automated (low density)
C         14       High-density water vapor sounder, channel 10
C         15       High-density water vapor sounder, channel 11
C                     (14 can be changed to this further down in code)
C         16       High-density IR (LW) imager automated winds
C         17       High-density visible imager automated winds
C         18       High-density water vapor imager
C         19       High-density IR (SW) imager automated winds
C                     (16 can be changed to this further down in code)
C         99       Not applicable (default)


C SIDP            IR(LW,SW)  VISIBLE   WV-CLTOP  PTRIPLET  WV-DPLYR
C ----            ---------  --------  --------  --------  --------

C  9  **  High-Density Geostationary Imager (+ low-dens. p. triplet)  **
     $                  16,      17,        18,        3,       18,

C 10  **  High-Density Geostationary Sounder  **
     $                  99,      99,        14,       99,       14,


C 11  **  not used **
     $                                                   99,99,99,99,99,
C 12  **  not used **
     $                                                   99,99,99,99,99,


C 13  **  High-Density Polar-Orbiting Imager **
     $                  16,      17,        18,       99,       18,

C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 


C  9  **  Low-Density Geostationary Imager  **
     $                   1,       6,         4,       99,        4,

C 10  **  Low-Density Geostationary Sounder  **
     $                  99,      99,        99,       99,       99,


C 11  **  not used **
     $                                                   99,99,99,99,99,
C 12  **  not used **
     $                                                   99,99,99,99,99,


C 13  **  Low-Density Polar-Orbiting Imager **
     $                  99,      99,        99,       99,       99
     $ /

C---------------------------------------------------------------------


C  REPROCESS THE STN. ID FOR SATELLITE WIND REPORTS
C  ------------------------------------------------

C    REPROCESSED CHAR 1 -----> GOES:     SAT. NO. 251,255,259   GET 'A'
C                                        SAT. NO. 252,256       GET 'B'
C                                        SAT. NO. 253,257       GET 'C'
C                                        SAT. NO. 250,254,258   GET 'D'
C                                        (Note: Sat. No. 253 gets 'P'
C                                               if producer is JMA)
C                       -----> METEOSAT: SAT. NO.  52, 56       GET 'X'
C                                        SAT. NO.  53, 57       GET 'Y'
C                                        SAT. NO.  50, 54, 58   GET 'Z'
C                                        SAT. NO.  51, 55, 59   GET 'W'
C                                        SAT. NO.  70           GET 'Z'
C                                        SAT. NO.  99 (UNKNOWN) GET 'X'
C                       -----> GMS(JA):  SAT. NO. 152           GET 'P'
C                                        SAT. NO. 150           GET 'R'
C                                        SAT. NO. 151           GET 'O'
C                                        (Note: Sat. No. 253 gets 'C'
C                                               if producer is NESDIS)
C                       -----> MTSAT:    SAT. NO. 171,175       GET 'Q'
C                                        SAT. NO. 172,176       GET 'R'
C                       -----> HIMAWARI: SAT. NO. 173           GET 'O'
C                                        SAT. NO. 174           GET 'P'
C                                        SAT. NO. 199 (UNKNOWN) GET 'Q'
C                       -----> KALPANA:  SAT. NO. 440           GET 'K'
C                       -----> INSAT:    SAT. NO. 470           GET 'V'
C                                        SAT. NO. 499 (UNKNOWN) GET 'V'
C                       -----> TERRA:    SAT. NO. 783           GET 'T'
C                       -----> AQUA:     SAT. NO. 784           GET 'U'
C                       -----> METOP:    SAT. NO.   3           GET 'H'
C                                        SAT. NO.   4           GET 'E'
C                                        SAT. NO.   5           GET 'I'
C                       -----> NOAA:     SAT. NO. 206           GET 'F'
C                                        SAT. NO. 207           GET 'L'
C                                        SAT. NO. 208           GET 'M'
C                                        SAT. NO. 209           GET 'N'
C                                        SAT. NO. 223           GET 'G'
C                       -----> NPP:      SAT. NO. 224           GET 'J'
C                       -----> NOAA:     SAT. NO. 225           GET 'S'
C    REPROCESSED CHAR 2 -----> WINDS PRODUCED BY NESDIS/NASA:
C                               RETURNED VALUE IN BUFR FOR 'SWPR'
C                               (PRODUCER), IF NON-MISSING; OTHERWISE
C                               HARDWIRED TO '1' (NESDIS), '9' (NASA)
C                       -----> WINDS PRODUCED BY FOREIGN PRODUCERS:
C                                SAT. PRODUCER -- ESA           GET 'C'
C                                              -- JMS           GET 'D'
C                                              -- INDIA         GET 'E'
C    REPROCESSED CHAR 3-7 ---> SEQUENTIAL SERIAL INDEX (00001 - 99999)
C                              (UNIQUE FOR EACH NCEP BUFR CHAR 1/2/8
C                               COMB.)
C    REPROCESSED CHAR 8 -----> WINDS PRODUCED BY NESDIS (INCL. AVHRR)
C                              AND NASA/MODIS (INCL. VIIRS):
C                               OLD FORMAT, (GOES -LOW-DENSITY-OBSOLETE)
C                                     -- IR (LW) CLOUD DRIFT     GET 'C'
C                                     -- VISIBLE CLOUD DRIFT     GET 'C'
C                                     -- PICTURE TRIPLET         GET 'C'
C                                     -- WATER VAPOR             GET 'V'
C                               NEW FORMAT, (GOES - LOW-DENSITY)
C                                     -- PICTURE TRIPLET         GET 'P'
C                               NEW FORMAT (GOES - HIGH-DENSITY, AQUA/
C                                           TERRA POES, NOAA/METOP POES,
C                                           NPP/POES)
C                                     -- IR (LW) IMGR CLD DRIFT  GET 'I'
C                                     -- VIS IMAGER CLOUD DRIFT  GET 'Z'
C                                        (GOES ONLY)
C                                     -- WATER VAPOR IMAGER      GET 'W'
C                                        (GOES, AQUA/TERRA POES ONLY)
C                                     -- WATER VAPR SNDR, CHN 10 GET 'T'
C                                        (GOES ONLY)
C                                     -- WATER VAPR SNDR, CHN 11 GET 'L'
C                                        (GOES ONLY)
C                                     -- IR (SW) IMGR CLD DRIFT  GET 'S'
C                                        (GOES ONLY)
C                               NEW FORMAT (GMS/MTSAT/
C                                                HIMAWARI - LOW-DENSITY)
C                                     -- IR (LW) CLOUD DRIFT     GET 'C'
C                                     -- WATER VAPOR             GET 'V'
C                       -----> WINDS PRODUCED BY FOREIGN PRODUCERS:
C                                     -- IR (LW) CLOUD DRIFT     GET 'C'
C                                     -- VISIBLE CLOUD DRIFT     GET 'B'
C                                     -- WATER VAPOR             GET 'V'

      DO WHILE(IREADMG(LUBFI,SUBSET,IDATE).EQ.0)

cppppp
cdak     call ufbcnt(lubfi,ireci,idummy)
cdak     isubi = nmsub(lubfi)
cdak     isubi_t = isubi_t + isubi
cdak     print *, '===> READ IN BUFR DATA MSG # ',ireci,' -- TABLE A ',
cdak $    'ENTRY "',SUBSET,'", DATE ',idate,' - ',isubi,' RPTS IN MSG;',
cdak $    ' TOTAL # RPTS SO FAR ',isubi_t
cppppp

C  If no subsets in msg & dummy msgs not expected, loop to nxt input msg
C  ---------------------------------------------------------------------

         IF(NMSUB(LUBFI).LE.0.AND.DUMMY_MSGS.NE.'YES')  CYCLE

         IF(NMSUB(LUBFI).EQ.0) THEN
cppppp
cdak        if(ireci.eq.1)  then
cdak           print *, '   -- this is dummy message 1, the center ',
cdak $          'time - copy to output file'
cdak        else if(ireci.eq.2)  then
cdak           print *, '   -- this is dummy message 2, the dump time ',
cdak $          '- copy to output file'
cdak        else
cdak           print *, '   -- this message has no reports in it for ',
cdak $          'some unexplained reason!! (go ahead and copy to ',
cdak $          'output file'
cdak        endif
cppppp
            CALL CLOSMG(LUBFJ)
            CALL COPYMG(LUBFI,LUBFJ)
cppppp
cdak        call ufbcnt(lubfj,ireco,isubo)
cdak        if(ireco.gt.ireco_l)  then
cdak           isubo_t = isubo_t + isubo_l
cdak           print *, ' --- OPEN EMPTY BUFR MSG WITH DATE',idate,
cdak $          ': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,' RPTS',
cdak $          ' (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak        endif
cdak        isubo_l = isubo
cdak        ireco_l = ireco
cppppp
            CYCLE
         ENDIF

         DO WHILE(IREADSB(LUBFI,IRET).EQ.0)
            ISUB = ISUB+1
            IDUP = JDUP(ISUB)          ! check the dupe code
            NDUP(IDUP) = NDUP(IDUP)+1  ! count dupe types
            ILON = JLON(ISUB)          ! check the lon corr. code
            IF(IDUP.NE.0)  CYCLE ! this is a duplicate, skip it
            CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SAID')
            SAID = UFBINT_8
            ITP = 99
            SID = '????????'
            IPRODUCER = 99
            IDENSITY  = 99
            IF(NINT(SAID).LT.785)  THEN
               SID(1:1) = CSAT(NINT(SAID))
C     .... GOES-9 winds with BUFR message subtype 41-46 always get "P"
C          in 1st char. of stn. id (JMA began producing winds from
C          GOES-9 in place of failing GMS-5 on 23 May 2003, this lasted
C          until 15 July 2005 when MTSAT-1R replaced GOES-9)
C          (Note: When NESDIS produces winds from GOES-9, the first
C                 char. in the stn. id is "C", but that would cause
C                 problems in PREPOBS_PREPDATA in this case)
               IF(NINT(SAID).EQ.253.AND.SUBSET(7:7).EQ.'4')SID(1:1)= 'P'
               IF((SID(1:1).GE.'A'.AND.SID(1:1).LE.'D') .OR.
     $          (SUBSET(7:8).EQ.'50'.OR.SUBSET(7:8).EQ.'51') .OR.
     $          (SUBSET(7:8).EQ.'70'.OR.SUBSET(7:8).EQ.'71') .OR.
     $          (SUBSET(7:8).EQ.'80') .OR.
     $          (SUBSET(7:8).EQ.'90')) THEN
                  IF(SUBSET(7:8).EQ.'50'.OR.SUBSET(7:8).EQ.'51') THEN
                     IDENSITY = 2
                  ELSE
                     IDENSITY = 1
                  ENDIF
C  .. Satellite producer for winds generated by NESDIS/NASA
                  CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SWPR')
                  SWPR_8=UFBINT_8
                  IF(IBFMS(SWPR_8).EQ.0) THEN       ! data not missing
                                   ! From NESDIS Binary Fmt (local)
                                   !  (both lo- and hi- density)
                     IF(NINT(SWPR_8).GT.0.AND.NINT(SWPR_8).LT.10)
     $                WRITE(SID(2:2),'(I1)') NINT(SWPR_8)
                  ELSE
                     CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'GCLONG')
                     GCLONG=UFBINT_8
                                   ! From NESDIS BUFR Fmt (WMO)
                                   !  Should come in as 160 (NESDIS),
                                   !  but irregardless hardwire here as
                                   !  1 if NESDIS and 9 if NASA
                     SID(2:2) = '1'
                     IF(SUBSET(7:8).EQ.'70'.OR.SUBSET(7:8).EQ.'71'.OR.
     $                  SUBSET(7:8).EQ.'90')
     $                SID(2:2) = '9'
                  ENDIF
                  IPRODUCER=1
C  .. Product type for winds generated by NESDIS/NASA
                  CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SWTP')
                  SWTP_8=UFBINT_8
                  CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'CMCM')
                  CMCM_8=UFBINT_8
                  IF(IBFMS(SWTP_8).EQ.0) THEN        ! data not missing
                     ITP = NINT(SWTP_8) ! From NESDIS Binary Fmt (local)
                                      !  (hi- density)
                  ELSE  IF(IBFMS(CMCM_8).EQ.0)  THEN    ! data not missing
                                   ! From NESDIS Binary Fmt (local)
                                   !  (lo- density)
                                   ! (Note: CMCM_8 is non-missing in this
                                   !        case but may not be correct!
                     IF(SUBSET(7:8).EQ.'01')  THEN
                        ITP = 1
                     ELSE  IF(SUBSET(7:8).EQ.'02')  THEN
                        ITP = 6
                     ELSE  IF(SUBSET(7:8).EQ.'03')  THEN
                        ITP = 4
                     ELSE  IF(SUBSET(7:8).EQ.'04')  THEN
                        ITP = 3
                     ENDIF
                  ELSE
                     CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SWCM')
                     SWCM=UFBINT_8
                     CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SIDP')
                     SIDP=UFBINT_8

C  Effective 3/10/2005 NESDIS fixed an error which had stored SIDP as
C   a code table value rather than correctly as a flag table value
C  In 2015 this happened again for VIIRS POES winds (NESDIS stored SIDP
C   as 13 rather than as 262144 prior to fixing)
C  - in response must redirect SIDP value back to original code table
C    value (will still work ok for historical runs prior to NESDIS fix)
C  --------------------------------------------------------------------

                     IF(NINT(SIDP).EQ.4194304) THEN
                        SIDP =  9
                     ELSE  IF(NINT(SIDP).EQ.2097152) THEN
                        SIDP = 10
                     ELSE  IF(NINT(SIDP).EQ.262144) THEN
                        SIDP = 13
                     ENDIF
                     IF((NINT(SWCM).GT. 0.AND.NINT(SWCM).LT. 6).AND.
     $                  (NINT(SIDP).EQ. 9.OR. NINT(SIDP).EQ.10
     $                                   .OR. NINT(SIDP).EQ.13))
                                      !From NESDIS BUFR Fmt (WMO)
     $                ITP = ISWCM(NINT(SWCM),NINT(SIDP),IDENSITY)
                      IF(ITP.EQ.16)  THEN
                         CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SCCF')
                         SCCF = UFBINT_8
                         SCCF = SCCF*1E-11
                         IF(INT(SCCF).EQ.769)  ITP = 19 ! IR (SW) chn
                      ELSE IF(ITP.EQ.14)  THEN
                         CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SCCF')
                         SCCF = UFBINT_8
                         SCCF = SCCF*1E-11
                         IF(INT(SCCF).EQ.405)  ITP = 15 ! WV ch 11
                      ENDIF
                  ENDIF
                  READ(SUBSET(7:8),'(I2)') INUM2
                  IF(INUM2.LT.91)  SID(8:8) = CPRDFN(INUM2)
                  IF(SID(8:8).EQ.'T')  THEN
                     IF(ITP.EQ.15)  SID(8:8) = 'L'
                  ENDIF
               ELSE
C  .. Satellite producer for winds generated from foreign producers
                  SID(2:2) = CPROD(NINT(SAID)/100)
C     .... GOES-9 winds with BUFR message subtype 41-46 are assumed to
C          be produced by JMA (JMA began producing winds from GOES-9
C          in place of failing GMS-5 on 23 May 2003, this lasted until
C          15 July 2005 when MTSAT-1R replaced GOES-9)
                  IF(NINT(SAID).EQ.253.AND.SUBSET(7:7).EQ.'4')
     $             SID(2:2)='D'
                  IPRODUCER=2
                  READ(SUBSET(8:8),'(I1)') INUM1
C  .. Product type for  winds generated from foreign producers
                  SID(8:8) = CPRDF(MOD(INUM1,3))
                  ITP = IPRDF(MOD(INUM1,3))
               ENDIF
            ENDIF
            IF(NINT(SAID).LT.785.AND.ITP.LT.20.AND.IPRODUCER.LT.3)  THEN
               KOUNT(NINT(SAID),ITP,IPRODUCER) =
     $          MIN(KOUNT(NINT(SAID),ITP,IPRODUCER)+1,99999)
               WRITE(SID(3:7),'(I5.5)')  KOUNT(NINT(SAID),ITP,IPRODUCER)
            ENDIF
cdak        print *, 'SID = ',sid
            CALL OPENMB(LUBFJ,SUBSET,IDATE)
            CALL UFBCPY(LUBFI,LUBFJ)
            CALL UFBINT(LUBFJ,RPID_8,1,1,IRET,'RPID')
C  .. Possibly encode longitude which has been corrected to BUFR std
            IF(ILON.NE.0)  THEN   ! this longitude was corrected
                                  ! encode the corrected value
               CLON_8 = LALO_8(2,ISUB)
               IF(LATLON_TYPE.EQ.'HI-RES') THEN
                  CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLONH')
               ELSE IF(LATLON_TYPE.EQ.'LO-RES') THEN
                  CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLON')
               ENDIF
               NLON = NLON +1             ! count lon corr. types
            ENDIF
            IF(ICOMP.EQ.1) THEN
C       ... write out compressed BUFR messages if input msgs are such
               CALL WRITCP(LUBFJ)
            ELSE
C       ... otherwise write out uncompressed BUFR messages
               CALL WRITSB(LUBFJ)
            ENDIF
         ENDDO  !  end of readsb loop
      ENDDO  !  end of readmg loop

      RETURN

      END

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    GOESND_ID
C   PRGMMR: KEYSER           ORG: NP22        DATE: 2013-07-01
C
C ABSTRACT: PERFORMS DUPLICATE CHECKING AND (OPTIONAL) TRIMMING TO
C   EXACT TIME WINDOW (DAY DOWN TO SECOND), AND THEN UPDATES THE REPORT
C   ID AND LONGITUDE {ALREADY CORRECTED TO BUFR STANDARD
C   (-180 --> +180, E+,W- INSTEAD OF 0 --> 360 E) IF NECESSARY} IN
C   OUTPUT FILE FOR GOES SOUNDINGS.
C
C PROGRAM HISTORY LOG:
C 2000-12-05  KEYSER -- ORIGINAL AUTHOR
C 2001-06-19  D. A. KEYSER -- RECOGNIZES BUFR TYPE/SUBTYPE 003/002 AS
C     GOES 1x1 (HI-RES) DATA, PART OF THE "GOESND" DUMP FILE; GOES
C     HI-RES REPORTS HAVE UNKNOWN PATH AND GET PROPER STNID CHAR. 8
C     CHARACTER IDENTIFYING THE SAT. NUMBER AND GET "H" IN STNID CHAR.
C     1 TO UNIQUELY IDENTIFY THEM
C 2001-07-20  D. A. KEYSER -- INCREASED MXTB FROM 800000 TO 2400000
C     TO HANDLE LARGE VOLUME GOES SFOV CLOUD-TOP PROCESSING
C 2001-10-01  D. A. KEYSER -- INCREASED MXTB FROM 2400000 TO 3600000
C     TO HANDLE LARGE VOLUME GOES SFOV CLOUD-TOP PROCESSING
C 2002-11-18  D. A. KEYSER -- MODIFICATIONS TO PREVENT ARRAY OVERFLOW
C     WHEN THERE ARE > MXTB REPORTS
C 2005-10-19  J. WOOLLEN  MODIFIED STREAM TO INCREASE EFFICIENCY
C 2006-12-06  D. KEYSER   CAN NOW PROCESS GOES SFOV (1x1) SOUNDING/
C     RADIANCE DATA IN SUBSET "NC003003"
c 2007-11-02  D. KEYSER   ENCODES ANY LONGITUDES THAT HAVE BEEN
C     CORRECTED TO BUFR STANDARD IN MAIN PROGRAM (I.E., 0 --> 360 E
C     CHANGED TO -180 --> +180, E+,W-)
c 2011-05-09  D. KEYSER   THE OUTPUT FILE WILL BE IN THE SAME BUFR
C     COMPRESSION STATE AS THE INPUT FILE (RATHER THAN ALWAYS
C     UNCOMPRESSED) (NOTE: CURRENTLY THIS TYPE ALWAYS COMES IN AS
C     UNCOMPRESSED SO THIS WOULD ONLY AFFECT FUTURE FILES FOR THIS TYPE
C     WHICH MIGHT COME IN AS COMPRESSED BUFR)
C 2013-01-13  J.WHITING  REPLACED TEST VS BMISS W/ IBFMS FUNCTION;
C     CHANGED IBFMS ARGS SAID & GSDP FROM 4- TO 8-BYTE REALS;
C     REMOVED BMISS DATA STATEMENT.
C 2013-07-01  D. KEYSER   ADDED GOES-15 (SAT. ID 259) TO COMMENTS
C
C USAGE:    CALL GOESND_ID(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
C                          LATLON_TYPE,ICOMP)
C   INPUT ARGUMENT LIST:
C     LUBFI    - INPUT  BUFR FILE UNIT NUMBER
C     LUBFJ    - OUTPUT BUFR FILE UNIT NUMBER
C     JDUP     - ARRAY CONTAINING DUPLICATE TYPE FOR ALL SUBSETS IN
C                INPUT BUFR FILE (SORTED) (0 - NOT A DUP, 1 - DUP,
C                2 - OUTSIDE TIME WINDOW, 3 - MISSING LAT OR LON,
C                4-7 - RESERVED)
C     JLON     - ARRAY CONTAINING LONGITUDE CORRECTION TYPE FOR ALL
C                SUBSETS IN INPUT BUFR FILE (SORTED) (0 - NO
C                CORRECTION, 1 - CORRECTION TO BUFR STANDARD)
C     LALO_8   - REAL(8) ARRAY CONTAINING LATITUDES AND LONGITUDES
C                (LATTER POSSIBLY CORRECTED) FOR ALL SUBSETS IN INPUT
C                BUFR FILE (SORTED)
C     LATLON_TYPE - CHARACTER*6 STRING INDICATING LAT/LON RESOLUTION
C                   (EITHER 'HI-RES', 'LO-RES', 'SSMILR' or 'NONE  ')
C     ICOMP    - INDICATOR AS TO WHETHER OR NOT INPUT BUFR MESSAGES ARE
C                COMPRESSED (0 - UNCOMPRESSED, 1 - COMPRESSED, ANYTHING
C                ELSE - UNKNOWN)
C
C   OUTPUT ARGUMENT LIST:
C     NDUP     - ARRAY HOLDING COUNTS ACCORDING TO DUPLICATE TYPE
C     NLON     - COUNTER OF REPORTS FOR WHICH A LONGITUDE CORRECTION
C                WAS PERFORMED
C
C   SUBPROGRAMS CALLED (incomplete list):
C     LIBRARY:
C       BUFRLIB  - IBFMS
C
C   INPUT FILES:
C     UNIT "LUBFI" - INPUT  BUFR FILE
C
C   OUTPUT FILES:
C     UNIT "LUBFJ" - OUTPUT BUFR FILE
C
C REMARKS: THE DUPLICATE CHECKING AND LONGITUDE CORRECTION ENCODING
C     LOGIC HERE IS NO DIFFERENT FROM THAT FOR ALL OTHER DATA TYPES
C     (SEE MAIN PROGRAM). THIS SUBROUTINE IS UNIQUE TO GOES SOUNDING
C     REPORTS BECAUSE IT GENERATES A NEW FORM OF THE REPORT ID WHICH IS
C     UNIQUE FOR ALL REPORTS IN THE OUTPUT FILE.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      SUBROUTINE GOESND_ID(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
     $                     LATLON_TYPE,ICOMP)

      CHARACTER*1  C8TAG(3,0:3)
      CHARACTER*8  SID,subset
      CHARACTER*6  LATLON_TYPE
      CHARACTER*3  DUMMY_MSGS

      REAL(8)  UFBINT_8,RPID_8,CLON_8,LALO_8(2,NTAB)
      REAL(8)  SAID_8, GSDP_8

      INTEGER  JDUP(NTAB),NDUP(0:7),KOUNT(3,0:3),JLON(NTAB)

      COMMON /COUNT/NTAB,ISUB,ISUBO_T,ISUBO_L,IRECO_L
      COMMON /DMSGS/DUMMY_MSGS

      EQUIVALENCE  (RPID_8,SID)

      data ireci/0/
      data isubi/0/
      data isubi_t/0/

      DATA KOUNT/12*0/


C     CURRENT LIST OF  SATELLITE IDENTIFIERS (BUFR C.F. 0-01-007)
C     -----------------------------------------------------------

C       GOES  6 -- 250     GOES  7 -- 251     GOES  8 -- 252
C       GOES  9 -- 253     GOES 10 -- 254     GOES 11 -- 255
C       GOES 12 -- 256     GOES 13 -- 257     GOES 14 -- 258
C       GOES 15 -- 259

C  IDSAT =       -- EVEN1 --   --- ODD1 --   -- EVEN2 --   --- ODD2 --
C   Sat. No. -   252,256,...   253,257,...   250,254,...   255,259,...
C  IRTYP =       CLR CLD UNKN  CLR CLD UNKN  CLR CLD UNKN  CLR CLD UNKN
C                --- --- ----  --- --- ----  --- --- ----  --- --- ----

      DATA C8TAG/'I','J','K',  'L','M','N',  'O','P','S',  'Q','R','T' /

      DO WHILE(IREADMG(LUBFI,SUBSET,IDATE).EQ.0)

cppppp
cdak     call ufbcnt(lubfi,ireci,idummy)
cdak     isubi = nmsub(lubfi)
cdak     isubi_t = isubi_t + isubi
cdak     print *, '===> READ IN BUFR DATA MSG # ',ireci,' -- TABLE A ',
cdak $    'ENTRY "',SUBSET,'", DATE ',idate,' - ',isubi,' RPTS IN MSG;',
cdak $    ' TOTAL # RPTS SO FAR ',isubi_t
cppppp

C  If no subsets in msg & dummy msgs not expected, loop to nxt input msg
C  ---------------------------------------------------------------------

         IF(NMSUB(LUBFI).LE.0.AND.DUMMY_MSGS.NE.'YES')  CYCLE

         IF(NMSUB(LUBFI).EQ.0) THEN
cppppp
cdak        if(ireci.eq.1)  then
cdak           print *, '   -- this is dummy message 1, the center ',
cdak $          'time - copy to output file'
cdak        else if(ireci.eq.2)  then
cdak           print *, '   -- this is dummy message 2, the dump time ',
cdak $          '- copy to output file'
cdak        else
cdak           print *, '   -- this message has no reports in it for ',
cdak $          'some unexplained reason!! (go ahead and copy to ',
cdak $          'output file'
cdak        endif
cppppp
            CALL CLOSMG(LUBFJ)
            CALL COPYMG(LUBFI,LUBFJ)
cppppp
cdak        call ufbcnt(lubfj,ireco,isubo)
cdak        if(ireco.gt.ireco_l)  then
cdak           isubo_t = isubo_t + isubo_l
cdak           print *, ' --- OPEN EMPTY BUFR MSG WITH DATE',idate,
cdak $          ': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,' RPTS',
cdak $          ' (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak        endif
cdak        isubo_l = isubo
cdak        ireco_l = ireco
cppppp
            CYCLE
         ENDIF

         DO WHILE(IREADSB(LUBFI).EQ.0)
            ISUB = ISUB+1
            IDUP = JDUP(ISUB)          ! check the dupe code
            NDUP(IDUP) = NDUP(IDUP)+1  ! count dupe types
            ILON = JLON(ISUB)          ! check the lon corr. code
cppppp
cdak        if(idup.eq.2)  print *, '--> uh-oh not in time window, toss'
cdak        if(idup.eq.1)  print *, '--> uh-oh a duplicate, toss'
cdak        if(idup.eq.3)  print *, '--> uh-oh missing lat/lon, toss'
cdak        if(idup.eq.4)  print *, '--> uh-oh ???????????, toss'
cdak        if(idup.eq.5)  print *, '--> uh-oh ???????????, toss'
cdak        if(idup.eq.6)  print *, '--> uh-oh ???????????, toss'
cdak      if(idup.eq.7)  print *, '--> uh-oh unreasonable lat/lon, toss'
cdak        if(idup.gt.7)  print *, '--> uh-oh ???????????, toss'
cdak        if(ilon.eq.1)  print *, '--> uh-oh longitude corrected'
cppppp
            IF(IDUP.NE.0)  CYCLE ! this is a duplicate, skip it
            CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'GSDP')
            GSDP_8 = UFBINT_8
            CALL UFBINT(LUBFI,UFBINT_8,1,1,IRET,'SAID')
            SAID_8 = UFBINT_8
            SID = '????????'
            IRTYP = 3
            IF(IBFMS(GSDP_8).EQ.0) THEN   ! data not missing
               IF(NINT(GSDP_8).EQ.21)  THEN
                  IRTYP = 1
               ELSE  IF(NINT(GSDP_8).EQ.23)  THEN
                  IRTYP = 2
               ENDIF
            ENDIF ! IBFMS(GSDP_8)=0 (GSDP_8 not mising)
            IDSAT = 2

            IF(IBFMS(SAID_8).EQ.0)  IDSAT = MOD(NINT(SAID_8),4) ! data not missing
            SID(8:8) = C8TAG(IRTYP,IDSAT)
            KOUNT(IRTYP,IDSAT) = MIN(KOUNT(IRTYP,IDSAT)+1,9999999)
            WRITE(SID(1:7),'(I7.7)')  KOUNT(IRTYP,IDSAT)
            if(subset.eq.'NC003002'.or.subset.eq.'NC003003')
     $       sid(1:1) = 'H'
cdak        print *, 'SID = ',sid
            CALL OPENMB(LUBFJ,SUBSET,IDATE)
            CALL UFBCPY(LUBFI,LUBFJ)
            CALL UFBINT(LUBFJ,RPID_8,1,1,IRET,'RPID')
C  .. Possibly encode longitude which has been corrected to BUFR std
            IF(ILON.NE.0)  THEN   ! this longitude was corrected
                                  ! encode the corrected value
               CLON_8 = LALO_8(2,ISUB)
               IF(LATLON_TYPE.EQ.'HI-RES') THEN
                  CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLONH')
               ELSE IF(LATLON_TYPE.EQ.'LO-RES') THEN
                  CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLON')
               ENDIF
               NLON = NLON +1             ! count lon corr. types
            ENDIF
            IF(ICOMP.EQ.1) THEN
C       ... write out compressed BUFR messages if input msgs are such
               CALL WRITCP(LUBFJ)
            ELSE
C       ... otherwise write out uncompressed BUFR messages
               CALL WRITSB(LUBFJ)
            ENDIF
cppppp
cdak        call ufbcnt(lubfj,ireco,isubo)
cdak        if(ireco.gt.ireco_l)  then
cdak           isubo_t = isubo_t + isubo_l
cdak        print *, ' --- THIS REPORT OPENS NEW BUFR MSG WITH DATE ',
cdak $       idate,': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,
cdak $       ' RPTS (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak        endif
cdak        isubo_l = isubo
cdak        ireco_l = ireco
cppppp

         ENDDO ! end of readsb loop
      ENDDO ! end of readmg loop

      RETURN

      END

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    HIRS2
C   PRGMMR: KEYSER           ORG: NP22        DATE: 2011-05-09
C
C ABSTRACT: PERFORMS DUPLICATE CHECKING, BRIGHTNESS TEMPERATURE GROSS
C   CHECKING, (OPTIONAL) TRIMMING TO EXACT TIME WINDOW (DAY DOWN TO
C   SECOND), AND THEN UPDATES THE REPORT LONGITUDE {ALREADY CORRECTED
C   TO BUFR STANDARD (-180 --> +180, E+,W- INSTEAD OF 0 --> 360 E) IF
C   NECESSARY} IN OUTPUT FILE FOR ATOVS HIRS2 1B REPORTS.
C
C PROGRAM HISTORY LOG:
C 2005-10-19  KEYSER -- ORIGINAL AUTHOR
C 2007-11-02  D. KEYSER   ENCODES ANY LONGITUDES THAT HAVE BEEN
C     CORRECTED TO BUFR STANDARD IN MAIN PROGRAM (I.E., 0 --> 360 E
C     CHANGED TO -180 --> +180, E+,W-)
C 2011-05-09  D. KEYSER   THE OUTPUT FILE WILL NOW BE IN THE SAME BUFR
C     COMPRESSION STATE AS THE INPUT FILE (RATHER THAN ALWAYS
C     COMPRESSED) (NOTE: CURRENTLY THIS TYPE IS NOT USED, BUT IT HAD
C     ALWAYS COME IN AS COMPRESSED, SO THIS CHANGE WOULD NOT AFFECT ANY
C     RETROSPECTIVE RUNS)
C
C USAGE:    CALL HIRS2(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
C                      LATLON_TYPE,ICOMP)
C   INPUT ARGUMENT LIST:
C     LUBFI    - INPUT  BUFR FILE UNIT NUMBER
C     LUBFJ    - OUTPUT BUFR FILE UNIT NUMBER
C     JDUP     - ARRAY CONTAINING DUPLICATE TYPE FOR ALL SUBSETS IN
C                INPUT BUFR FILE (SORTED) (0 - NOT A DUP, 1 - DUP,
C                2 - OUTSIDE TIME WINDOW, 3-MISSING LAT OR LON,
C                4 - MISSING BRIGHTNESS TEMPERATURES (SET IN THIS
C                SUBROUTINE, 5-7 - RESERVED)
C     JLON     - ARRAY CONTAINING LONGITUDE CORRECTION TYPE FOR ALL
C                SUBSETS IN INPUT BUFR FILE (SORTED) (0 - NO
C                CORRECTION, 1 - CORRECTION TO BUFR STANDARD)
C     LALO_8   - REAL(8) ARRAY CONTAINING LATITUDES AND LONGITUDES
C                (LATTER POSSIBLY CORRECTED) FOR ALL SUBSETS IN INPUT
C                BUFR FILE (SORTED)
C     LATLON_TYPE - CHARACTER*6 STRING INDICATING LAT/LON RESOLUTION
C                   (EITHER 'HI-RES', 'LO-RES', 'SSMILR' or 'NONE  ')
C     ICOMP    - INDICATOR AS TO WHETHER OR NOT INPUT BUFR MESSAGES ARE
C                COMPRESSED (0 - UNCOMPRESSED, 1 - COMPRESSED, ANYTHING
C                ELSE - UNKNOWN)
C
C   OUTPUT ARGUMENT LIST:
C     NDUP     - ARRAY HOLDING COUNTS ACCORDING TO DUPLICATE TYPE
C     NLON     - COUNTER OF REPORTS FOR WHICH A LONGITUDE CORRECTION
C                WAS PERFORMED
C
C   INPUT FILES:
C     UNIT "LUBFI" - INPUT  BUFR FILE
C
C   OUTPUT FILES:
C     UNIT "LUBFJ" - OUTPUT BUFR FILE
C
C REMARKS: THE DUPLICATE CHECKING AND LONGITUDE CORRECTION ENCODING
C     LOGIC HERE IS NO DIFFERENT FROM THAT FOR ALL OTHER DATA TYPES
C     (SEE MAIN PROGRAM). THIS SUBROUTINE IS UNIQUE TO ATOVS HIRS2 1B
C     REPORTS BECAUSE IT ALSO GROSS CHECKS THE BRIGHTNESS TEMPERATURE
C     DATA FOR EACH REPORT, TOSSING THE REPORT IF THE BRIGHTNESS
C     TEMPERATURE FOR CHANNEL 8 IS MISSING (THIS INDICATES THAT ALL
C     BRIGHTNESS TEMPERATURES FOR THE REPORT ARE MOST LIKELY MISSING).
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      SUBROUTINE HIRS2(LUBFI,LUBFJ,JDUP,NDUP,JLON,NLON,LALO_8,
     $                 LATLON_TYPE,ICOMP)

      CHARACTER*8  SUBSET
      CHARACTER*6  LATLON_TYPE
      CHARACTER*3  DUMMY_MSGS

      REAL(8)  TMBR_8(20),CLON_8,LALO_8(2,NTAB)

      INTEGER  JDUP(NTAB),NDUP(0:7),JLON(NTAB)

      COMMON /COUNT/NTAB,ISUB,ISUBO_T,ISUBO_L,IRECO_L
      COMMON /DMSGS/DUMMY_MSGS

      data ireci/0/
      data isubi/0/
      data isubi_t/0/

      DO WHILE(IREADMG(LUBFI,SUBSET,IDATE).EQ.0)

cppppp
cdak     call ufbcnt(lubfi,ireci,idummy)
cdak     isubi = nmsub(lubfi)
cdak     isubi_t = isubi_t + isubi
cdak     print *, '===> READ IN BUFR DATA MSG # ',ireci,' -- TABLE A ',
cdak $    'ENTRY "',SUBSET,'", DATE ',idate,' - ',isubi,' RPTS IN MSG;',
cdak $    ' TOTAL # RPTS SO FAR ',isubi_t
cppppp

C  If no subsets in msg & dummy msgs not expected, loop to nxt input msg
C  ---------------------------------------------------------------------

         IF(NMSUB(LUBFI).LE.0.AND.DUMMY_MSGS.NE.'YES')  CYCLE

         IF(NMSUB(LUBFI).EQ.0) THEN
cppppp
cdak        if(ireci.eq.1)  then
cdak           print *, '   -- this is dummy message 1, the center ',
cdak $          'time - copy to output file'
cdak        else if(ireci.eq.2)  then
cdak           print *, '   -- this is dummy message 2, the dump time ',
cdak $          '- copy to output file'
cdak        else
cdak           print *, '   -- this message has no reports in it for ',
cdak $          'some unexplained reason!! (go ahead and copy to ',
cdak $          'output file'
cdak        endif
cppppp
            CALL CLOSMG(LUBFJ)
            CALL COPYMG(LUBFI,LUBFJ)
cppppp
cdak        call ufbcnt(lubfj,ireco,isubo)
cdak        if(ireco.gt.ireco_l)  then
cdak           isubo_t = isubo_t + isubo_l
cdak           print *, ' --- OPEN EMPTY BUFR MSG WITH DATE',idate,
cdak $          ': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,' RPTS',
cdak $          ' (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak        endif
cdak        isubo_l = isubo
cdak        ireco_l = ireco
cppppp
            CYCLE
         ENDIF

         DO WHILE(IREADSB(LUBFI).EQ.0)
            ISUB = ISUB+1
            IDUP = JDUP(ISUB)          ! check the dupe code
            CALL UFBREP(LUBFI,TMBR_8,1,20,IRET,'TMBR')
            IF(TMBR_8(8).GE.500.)  IDUP = 4
            NDUP(IDUP) = NDUP(IDUP)+1  ! count dupe types
            ILON = JLON(ISUB)          ! check the lon corr. code
cppppp
cdak        if(idup.eq.2)  print *, '--> uh-oh not in time window, toss'
cdak        if(idup.eq.1)  print *, '--> uh-oh a duplicate, toss'
cdak        if(idup.eq.3)  print *, '--> uh-oh missing lat/lon, toss'
cdak        if(idup.eq.4)  print *, '--> uh-oh missing TMBR, toss'
cdak        if(idup.eq.5)  print *, '--> uh-oh ???????????, toss'
cdak        if(idup.eq.6)  print *, '--> uh-oh ???????????, toss'
cdak      if(idup.eq.7)  print *, '--> uh-oh unreasonable lat/lon, toss'
cdak        if(idup.gt.7)  print *, '--> uh-oh ???????????, toss'
cdak        if(ilon.eq.1)  print *, '--> uh-oh longitude corrected'
cppppp
            IF(IDUP.NE.0)  CYCLE ! this is a duplicate, skip it
            CALL OPENMB(LUBFJ,SUBSET,IDATE)
            CALL UFBCPY(LUBFI,LUBFJ)
            CALL UFBINT(LUBFJ,RPID_8,1,1,IRET,'RPID')
C  .. Possibly encode longitude which has been corrected to BUFR std
            IF(ILON.NE.0)  THEN   ! this longitude was corrected
                                  ! encode the corrected value
               CLON_8 = LALO_8(2,ISUB)
               IF(LATLON_TYPE.EQ.'HI-RES') THEN
                  CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLONH')
               ELSE IF(LATLON_TYPE.EQ.'LO-RES') THEN
                  CALL UFBINT(LUBFJ,CLON_8,1,1,IRET,'CLON')
               ENDIF
               NLON = NLON +1             ! count lon corr. types
            ENDIF
            IF(ICOMP.EQ.1) THEN
C       ... write out compressed BUFR messages if input msgs are such
               CALL WRITCP(LUBFJ)
            ELSE
C       ... otherwise write out uncompressed BUFR messages
               CALL WRITSB(LUBFJ)
            ENDIF
cppppp
cdak        call ufbcnt(lubfj,ireco,isubo)
cdak        if(ireco.gt.ireco_l)  then
cdak           isubo_t = isubo_t + isubo_l
cdak        print *, ' --- THIS REPORT OPENS NEW BUFR MSG WITH DATE ',
cdak $       idate,': LAST MSG WAS NO.',ireco-1,' WITH',isubo_l,
cdak $       ' RPTS (TOTAL NO. RPTS WRITTEN=',isubo_t,')'
cdak        endif
cdak        isubo_l = isubo
cdak        ireco_l = ireco
cppppp

         ENDDO ! end of readsb loop
      ENDDO ! end of readmg loop

      RETURN

      END

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM: CHDIST
C   PRGMMR: D. KEYSER        ORG: NP22       DATE: 2004-02-02
C
C ABSTRACT:  COMPUTES CHORD LENGTH DISTANCE FROM ONE LAT/LON POINT
C   TO ANOTHER LAT/LON POINT USING THE FORMULA:
C     S**2/2 = 1 - COS(Y1-Y2) + COS(Y1)*COS(Y2)*(1-COS(X1-X2)).
C
C PROGRAM HISTORY LOG:
C 1990-11-06  J. WOOLLEN -- ORIGINAL AUTHOR
C 2004-02-02  D. KEYSER  -- CORRECTED SUBROUTINE ARGUMENT MISALIGNMENT
C    (THIS DID NOT APPEAR TO CAUSE PROBLEMS IN OUTPUT BUT COULD CAUSE
C    MEMORY CLOBBERING DOWN THE LINE SOMEWHERE)
C
C USAGE:  CALL CHDIST(X1,Y1,X2,Y2,DIST)
C   INPUT ARGUMENTS:
C     X1         - LONGITUDE (0.-360. W) OF POINT 1
C     Y1         - LATITUDE  (N+,S-)     OF POINT 1
C     X2         - LONGITUDE (0.-360. W) OF POINT 2
C     Y2         - LATITUDE  (N+,S-)     OF POINT 2
C
C   OUTPUT ARGUMENTS:
C     DIST       - CHORD LENGTH DISTANCE BETWEEN POINTS (KM)
C
C REMARKS: NONE
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      SUBROUTINE CHDIST(X1,Y1,X2,Y2,DIST)

      DATA PI180/.0174532 /,RADE/6371./

      SAVE PI180,RADE

C  COMPUTE THE DISTANCE
C  --------------------

      COSY1 = COS(Y1*PI180)
      COSY2 = COS(Y2*PI180)
      COSDX = COS((X1-X2)*PI180)
      COSDY = COS((Y1-Y2)*PI180)
      S = 1.0-COSDY+COSY1*COSY2*(1.0-COSDX)
      S = SQRT(2.*S)
      IF(S.LE..002) S = 0.
      DIST = S*RADE

      RETURN
      END

C$$$  SUBPROGRAM DOCUMENTATION BLOCK
C
C SUBPROGRAM:    GEOCHK
C   PRGMMR: D. KEYSER        ORG: NP22       DATE: 2007-06-13
C      
C ABSTRACT: CHECKS THE VALUES OF THE FOUR MASK LAT/LON GRID POINTS
C   SURROUNDING A REPORT (BASED ON ITS LAT/LON).  BASED ON THE TYPE OF
C   CHECK WILL FLAG THE REPORT WITH "IGEO=1" IF ANY ONE (ICHK=2) OR IF
C   ALL FOUR (ICHK=1) SURROUNDING GRID POINTS HAVE A VALUE OF 1. MASK
C   IS ASSUMED TO HAVE VALUES OF 0 (OUTSIDE DOMAIN) OR 1 (INSIDE
C   DOMAIN).  THE MASK IS INTEGER*4.
C
C PROGRAM HISTORY LOG:
C 2007-06-03  D. A. KEYSER (W/NMC22)
C
C USAGE:    CALL GEOCHK(ALAT,ALONE,ICHK,MASK_4,NX,NY,DEL,IGEO)
C   INPUT ARGUMENT LIST:
C     ALAT     - LATITUDE OF DATA REPORT  (DEG. N+,S-)
C     ALONE    - LONGITUDE OF DATA REPORT (DEG. 0.-360. E)
C     ICHK     - TYPE OF CHECK:
C                   = 1 - ALL SURROUNDING GRID POINTS MUST BE 1
C                   = 2 - AT LEAST ONE SURROUNDING GRID POINT MUST BE 1
C                IF SATISFIED, OUTPUT ARGUMENT "IGEO" SET TO 1;
C                OTHERWISE "IGEO" SET TO 0
C     MASK_4   - INTEGER*4 NX x NY GRID ("DEL" DEGREE MASK)
C     NX       - NUMBER OF X-DIRECTION POINTS (COLUMNS, CORRESPONDING
C                TO LONGITUDE) IN "MASK_4"
C     NY       - NUMBER OF Y-DIRECTION POINTS (ROWS, CORRESPONDING TO
C                LATITUDE) IN "MASK_4"
C     DEL      - GRID SPACING OF MASK (IN DEGREES) (SEE REMARKS)
C
C   OUTPUT ARGUMENT LIST:
C     IGEO     - RETURN FLAG FOR CHECK (=0 "ICHK" NOT SATISFIED; =1
C                "ICHK" IS SATISFIED)
C
C REMARKS: THE GRID SPACING (IN DEGREES) FOR THE MASK (DEL) CAN BE
C   EITHER 0.25, 0.5, 1.0 OR 2.0.
C
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE:  WCOSS
C
C$$$
      SUBROUTINE GEOCHK(ALAT,ALONE,ICHK,MASK_4,NX,NY,DEL,IGEO)

      INTEGER(4) MASK_4(NX,NY)

      DATA IFIRST/0/

      IF(IFIRST.EQ.0) THEN
         IF(DEL.NE..25.AND.DEL.NE..5.AND.DEL.NE.1..AND.DEL.NE.2.) THEN
            PRINT'("#####BUFR_DUPSAT - LATITUDE SPACING IN MASK (="'//
     $       'G0,") NOT VALID - MUST BE EITHER 0.25, 0.5, 1.0 OR 2.0")',
     $       DEL
            CALL W3TAGE('BUFR_DUPSAT')
            CALL ERREXIT(99)
         ENDIF
         IFIRST = 1
      ENDIF

      IGEO = 0

cppppp
ccc   print *, '-- new report into geochk: ALAT,ALONE: ',ALAT,ALONE
cppppp
      XX = ALONE +  DEL
      YY = ALAT  +  90 + DEL

      IHX_L = (1/DEL)*XX
      IHX_H = IHX_L + 1
      IF(IHX_H.EQ.NX+1) IHX_H = 1
      IF(IHX_L.LT.1 .OR. IHX_L.GT.NX) THEN
         PRINT *, '#####BUFR_DUPSAT - LONGITUDE INDEX IN MASK (=',IHX_L,
     $    ') OUT OF RANGE'
         PRINT *, '     LAT = ',ALAT,', LON(E) = ',ALONE
cccccccc CALL W3TAGE('BUFR_DUPSAT')
cccccccc CALL ERREXIT(99)
         RETURN
      ENDIF

      IHY_L = (1/DEL)*YY
      IHY_H = IHY_L + 1
      IF(IHY_L.EQ.NY) IHY_H = NY
      IF(IHY_L.LT.1 .OR. IHY_L.GT.NY) THEN
         PRINT *, '#####BUFR_DUPSAT - LATITUDE INDEX IN MASK (=',IHY_L,
     $    ') OUT OF RANGE'
         PRINT *, '     LAT = ',ALAT,', LON(E) = ',ALONE
cccccccc CALL W3TAGE('BUFR_DUPSAT')
cccccccc CALL ERREXIT(99)
         RETURN
      ENDIF

cppppp
ccc   print *, '-- IHX_L,IHX_H,IHY_L,IHY_H: ',IHX_L,IHX_H,IHY_L,IHY_H
cppppp

C-----------------------------------------------------------------------
C      CHECK FOUR GRID POINTS SURROUNDING REPORT -- TWO METHODS
C-----------------------------------------------------------------------

      IF(ICHK.EQ.1)  THEN

C  CHECK 1-> ALL SURROUNDING PTS IN MASK MUST BE 1 (MOST RESTRICTIVE)
C  ------------------------------------------------------------------

         IF(MASK_4(IHX_L,IHY_L).EQ.1.AND.MASK_4(IHX_H,IHY_L).EQ.1.AND.
     $    MASK_4(IHX_L,IHY_H).EQ.1.AND.MASK_4(IHX_H,IHY_H).EQ.1) IGEO=1
      ELSE

C  CHECK 2-> ONLY 1 SURROUNDING PT IN MASK MUST BE 1 (LEAST RESTRICTIVE)
C  --------------------------------------------------------------------

cppppp
ccc   print *, '-- MASK_4(IHX_L,IHY_L),MASK_4(IHX_H,IHY_L),
ccc  $ MASK_4(IHX_L,IHY_H),MASK_4(IHX_H,IHY_H) : ', 
ccc  $ MASK_4(IHX_L,IHY_L),MASK_4(IHX_H,IHY_L),MASK_4(IHX_L,IHY_H),
ccc  $ MASK_4(IHX_H,IHY_H)
cppppp
         IF(MASK_4(IHX_L,IHY_L).EQ.1.OR.MASK_4(IHX_H,IHY_L).EQ.1.OR.
     $    MASK_4(IHX_L,IHY_H).EQ.1.OR.MASK_4(IHX_H,IHY_H).EQ.1)  IGEO=1
cppppp
ccc   print *, '-- coming out of geochk, IGEO = ',IGEO
cppppp

      END IF

      RETURN
      END
